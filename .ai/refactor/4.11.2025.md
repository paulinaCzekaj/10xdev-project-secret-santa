# Analiza Refaktoryzacji Komponent√≥w - 4.11.2025

## PrzeglƒÖd

Dokument przedstawia szczeg√≥≈ÇowƒÖ analizƒô TOP 5 najwiƒôkszych komponent√≥w w projekcie Secret Santa pod kƒÖtem z≈Ço≈ºono≈õci, identyfikacji problem√≥w oraz rekomendacji refaktoryzacyjnych zgodnych z best practices React 19, TypeScript 5 i Astro 5.

---

## üìä TOP 5 PLIK√ìW O NAJWIƒòKSZEJ Z≈ÅO≈ªONO≈öCI (LOC)

### 1. WishlistEditor.tsx - 336 linii
**Lokalizacja:** `src/components/result/WishlistEditor.tsx`

### 2. ParticipantCard.tsx - 282 linie
**Lokalizacja:** `src/components/group/ParticipantCard.tsx`

### 3. AddExclusionForm.tsx - 239 linii
**Lokalizacja:** `src/components/group/AddExclusionForm.tsx`

### 4. GroupView.tsx - 215 linii
**Lokalizacja:** `src/components/group/GroupView.tsx`

### 5. ForgotPasswordForm.tsx - 214 linii
**Lokalizacja:** `src/components/auth/ForgotPasswordForm.tsx`

---

## üîç SZCZEG√ì≈ÅOWA ANALIZA I REKOMENDACJE

### 1. WishlistEditor.tsx (336 linii) - üî¥ NAJWY≈ªSZY PRIORYTET

#### Struktura obecna:
- Komponent edytora listy ≈ºycze≈Ñ z funkcjƒÖ autosave
- Integracja z AI (generowanie listu do Miko≈Çaja)
- 3 modalne okna (prompt, preview, main editor)
- Obs≈Çuga 2 stan√≥w: edytowalny vs. zablokowany

#### Zidentyfikowane problemy:

**1. Naruszenie Single Responsibility Principle**
Komponent ma 7 r√≥≈ºnych odpowiedzialno≈õci:
- Edycja listy ≈ºycze≈Ñ
- ZarzƒÖdzanie stanem AI (generowanie, akceptowanie, odrzucanie)
- Obs≈Çuga modal√≥w (3 r√≥≈ºne)
- Formatowanie dat
- Wy≈õwietlanie statystyk wishlist
- Obs≈Çuga stan√≥w: loading, b≈Çƒôd√≥w, zapisywania
- Logika walidacji (character count)

**2. Nadmierna z≈Ço≈ºono≈õƒá renderowania**
- 122 linie czystego JSX (linie 122-335)
- Zagnie≈ºd≈ºona logika warunkowa (linie 266-292) - 27 linii inline IIFE dla statystyk
- Dwa ca≈Çkowicie r√≥≈ºne UI flows w jednym komponencie (locked vs editable)

**3. Du≈ºa liczba props (7)**
```typescript
interface WishlistEditorProps {
  participantId: string
  groupId: string
  initialContent: string
  isLocked: boolean
  lockDate: string | null
  isRegistered: boolean
  groupBudget: number
}
```
Wskazuje na tight coupling z parent component.

**4. Mieszanie logiki prezentacyjnej z biznesowƒÖ**
- Formatowanie daty (linie 71-78) powinno byƒá w utility
- Logika statystyk (linie 266-292) powinna byƒá w osobnym komponencie lub hook

#### Rekomendowane wzorce refaktoryzacji:

##### A) Compound Component Pattern

**Przed:**
```typescript
// Wszystko w jednym komponencie - 336 linii
export function WishlistEditor({ participantId, groupId, ... }) {
  // 50+ linii state management
  // 30+ linii handlers
  // 20+ linii effects
  // 200+ linii JSX
}
```

**Po:**
```typescript
// Kompozycja z mniejszych, specjalizowanych komponent√≥w
export function WishlistEditor({ participantId, groupId }) {
  return (
    <WishlistEditorProvider participantId={participantId} groupId={groupId}>
      <WishlistEditor.Header />
      <WishlistEditor.Stats />
      <WishlistEditor.TextArea />
      <WishlistEditor.AIGenerator />
      <WishlistEditor.SaveIndicator />
    </WishlistEditorProvider>
  )
}

WishlistEditor.Header = WishlistEditorHeader
WishlistEditor.Stats = WishlistEditorStats
WishlistEditor.TextArea = WishlistEditorTextArea
WishlistEditor.AIGenerator = WishlistEditorAIGenerator
WishlistEditor.SaveIndicator = WishlistEditorSaveIndicator
```

**Zalety:**
- Lepszy separation of concerns
- ≈Åatwiejsze testowanie (ka≈ºdy subkomponent osobno)
- Wiƒôksza reusability
- Redukcja z≈Ço≈ºono≈õci z 336 do ~50-80 linii per komponent

##### B) Custom Hooks dla logiki biznesowej

**Wydziel logikƒô do dedykowanych hook√≥w:**

```typescript
// hooks/useWishlistEditor.ts
export const useWishlistEditor = (participantId: string, initialContent: string) => {
  const [content, setContent] = useState(initialContent)
  const { mutate: updateWishlist, isPending } = useUpdateWishlistMutation()

  const updateContent = useCallback((newContent: string) => {
    setContent(newContent)
    // Autosave logic
  }, [])

  return { content, updateContent, isSaving: isPending }
}

// hooks/useWishlistStats.ts
export const useWishlistStats = (content: string) => {
  return useMemo(() => ({
    chars: content.length,
    words: content.trim().split(/\s+/).filter(Boolean).length,
    lines: content.split('\n').length,
    percentage: (content.length / 10000) * 100
  }), [content])
}

// hooks/useWishlistDateFormatter.ts
export const useWishlistDateFormatter = () => {
  return useCallback((date: string | null) => {
    if (!date) return 'Brak daty'
    return new Date(date).toLocaleDateString('pl-PL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }, [])
}
```

**Zalety:**
- Testowalna logika (pure functions)
- Separation of concerns (logika oddzielona od UI)
- Reusability w innych komponentach
- Zgodne z React 19 best practices

##### C) Wydzielenie komponent√≥w prezentacyjnych

**Struktura plik√≥w po refaktoringu:**

```
src/components/result/wishlist-editor/
‚îú‚îÄ‚îÄ WishlistEditor.tsx              // G≈Ç√≥wny komponent (50 linii)
‚îú‚îÄ‚îÄ WishlistEditorProvider.tsx      // Context provider (40 linii)
‚îú‚îÄ‚îÄ WishlistEditorHeader.tsx        // Header z tytu≈Çem (30 linii)
‚îú‚îÄ‚îÄ WishlistEditorStats.tsx         // Statystyki (60 linii)
‚îú‚îÄ‚îÄ WishlistEditorTextArea.tsx      // Pole tekstowe (50 linii)
‚îú‚îÄ‚îÄ WishlistEditorLocked.tsx        // Widok zablokowany (40 linii)
‚îú‚îÄ‚îÄ WishlistEditorAIGenerator.tsx   // Sekcja AI (80 linii)
‚îî‚îÄ‚îÄ WishlistEditorSaveIndicator.tsx // Wska≈∫nik zapisu (25 linii)
```

**Przyk≈Çad komponentu WishlistEditorStats:**

```typescript
// WishlistEditorStats.tsx (~60 linii)
import { useWishlistStats } from '@/hooks/useWishlistStats'
import { Card, CardContent } from '@/components/ui/card'

interface WishlistEditorStatsProps {
  content: string
  maxLength?: number
}

export function WishlistEditorStats({
  content,
  maxLength = 10000
}: WishlistEditorStatsProps) {
  const stats = useWishlistStats(content)
  const isNearLimit = stats.chars > maxLength * 0.95

  return (
    <Card>
      <CardContent className="flex gap-4 p-3">
        <StatItem
          label="Znaki"
          value={stats.chars}
          max={maxLength}
          warning={isNearLimit}
        />
        <StatItem label="S≈Çowa" value={stats.words} />
        <StatItem label="Linie" value={stats.lines} />
      </CardContent>
    </Card>
  )
}

function StatItem({ label, value, max, warning }: StatItemProps) {
  return (
    <div className={cn("flex flex-col", warning && "text-destructive")}>
      <span className="text-sm text-muted-foreground">{label}</span>
      <span className="text-lg font-semibold">
        {value}
        {max && ` / ${max}`}
      </span>
    </div>
  )
}
```

**Argumentacja:**
- Zgodnie z React best practices: komponenty powinny mieƒá max 200 linii
- Single Responsibility Principle: ka≈ºdy komponent robi jednƒÖ rzecz
- ≈Åatwiejsze testowanie: snapshot tests dla UI, unit tests dla logiki
- Zgodne z wytycznymi z `CLAUDE.md`: preferuj funkcyjne komponenty z hookami

---

### 2. ParticipantCard.tsx (282 linie) - üî¥ WYSOKI PRIORYTET

#### Struktura obecna:
- Komponent karty uczestnika z edycjƒÖ inline
- Responsywny layout (mobile vs desktop)
- Obs≈Çuga 3 r√≥≈ºnych stan√≥w wizualnych (creator badge, wishlist status, result status)

#### Zidentyfikowane problemy:

**1. Duplikacja kodu mobile/desktop**
Linie 234-250 (desktop buttons) vs 252-274 (mobile dropdown) - ta sama logika, r√≥≈ºne UI:

```typescript
// Desktop (17 linii)
<div className="hidden md:flex gap-2">
  <Button onClick={onEditParticipant}>
    <Pencil className="h-4 w-4" />
  </Button>
  {/* ... wiƒôcej przycisk√≥w */}
</div>

// Mobile (23 linie) - DUPLIKACJA!
<DropdownMenu>
  <DropdownMenuItem onClick={onEditParticipant}>
    <Pencil className="h-4 w-4" />
    Edytuj
  </DropdownMenuItem>
  {/* ... wiƒôcej pozycji */}
</DropdownMenu>
```

**2. ZarzƒÖdzanie stanem edycji wewnƒÖtrz komponentu**
```typescript
const [isEditingEmail, setIsEditingEmail] = useState(false)
const [emailValue, setEmailValue] = useState(participant.email || "")

const handleSaveEmail = async () => {
  // 30+ linii logiki biznesowej w komponencie UI
}
```

**3. Zbyt wiele warunk√≥w renderowania**
- `isCreator && ...` (linia 99)
- `!isEditingEmail ? ... : ...` (linie 101-153)
- `isDrawn && ...` (linia 160)
- `!isDrawn && canEdit && ...` (linia 232)
- Prowadzi do trudno≈õci w testowaniu i debugowaniu

**4. Tight coupling z wieloma UI libraries**
U≈ºywa 6 r√≥≈ºnych komponent√≥w UI:
- Avatar, Badge, Tooltip, DropdownMenu, Button, Input
- Trudne do wymienienia biblioteki UI w przysz≈Ço≈õci

#### Rekomendowane wzorce refaktoryzacji:

##### A) Container/Presenter Pattern (Smart/Dumb Components)

**Przed:**
```typescript
// Wszystko w jednym - logika + UI
export function ParticipantCard({ participant, onEdit, ... }) {
  const [isEditingEmail, setIsEditingEmail] = useState(false)
  const handleSave = async () => { /* API calls */ }

  return (
    <Card>
      {/* 200+ linii JSX z logikƒÖ */}
    </Card>
  )
}
```

**Po:**
```typescript
// Container - zarzƒÖdza logikƒÖ
export function ParticipantCardContainer(props: ParticipantCardProps) {
  const {
    isEditing,
    emailValue,
    handleSave,
    handleCancel,
    handleStartEdit
  } = useParticipantEmailEdit(props.participant)

  return (
    <ParticipantCardPresenter
      {...props}
      isEditing={isEditing}
      emailValue={emailValue}
      onSave={handleSave}
      onCancel={handleCancel}
      onStartEdit={handleStartEdit}
    />
  )
}

// Presenter - czysty UI, zero logiki
export function ParticipantCardPresenter({
  participant,
  isEditing,
  emailValue,
  onSave,
  onCancel,
  ...
}: PresenterProps) {
  return (
    <Card>
      <ParticipantCardHeader participant={participant} />
      <ParticipantCardEmail
        email={participant.email}
        isEditing={isEditing}
        value={emailValue}
        onSave={onSave}
        onCancel={onCancel}
      />
      <ParticipantCardBadges participant={participant} />
      <ParticipantCardActions participant={participant} />
    </Card>
  )
}
```

**Zalety:**
- ≈Åatwiejsze testowanie UI (snapshot tests bez mock√≥w API)
- Logika biznesowa w dedykowanych hookach (≈Çatwe unit testy)
- Czysty kod, ≈Çatwy do zrozumienia

##### B) Responsive Component Composition zamiast duplikacji

**Zamiast duplikacji kodu:**

```typescript
// ‚ùå Z≈ÅE - duplikacja 46 linii kodu
<div className="hidden md:flex gap-2">
  <Button onClick={onEditParticipant}><Pencil /></Button>
  <Button onClick={onDeleteParticipant}><Trash /></Button>
  <Button onClick={onCopyToken}><Copy /></Button>
</div>

<DropdownMenu className="md:hidden">
  <DropdownMenuItem onClick={onEditParticipant}>
    <Pencil /> Edytuj
  </DropdownMenuItem>
  <DropdownMenuItem onClick={onDeleteParticipant}>
    <Trash /> Usu≈Ñ
  </DropdownMenuItem>
  <DropdownMenuItem onClick={onCopyToken}>
    <Copy /> Kopiuj token
  </DropdownMenuItem>
</DropdownMenu>
```

**U≈ºyj abstrakcji:**

```typescript
// ‚úÖ DOBRE - zero duplikacji
const actions = [
  { icon: Pencil, label: "Edytuj", onClick: onEditParticipant },
  { icon: Trash, label: "Usu≈Ñ", onClick: onDeleteParticipant, variant: "destructive" },
  { icon: Copy, label: "Kopiuj token", onClick: onCopyToken }
]

return (
  <ParticipantActions
    actions={actions}
    layout={isMobile ? 'dropdown' : 'buttons'}
  />
)
```

**Implementacja ParticipantActions:**

```typescript
// components/group/ParticipantActions.tsx
interface Action {
  icon: LucideIcon
  label: string
  onClick: () => void
  variant?: 'default' | 'destructive'
}

interface ParticipantActionsProps {
  actions: Action[]
  layout: 'buttons' | 'dropdown'
}

export function ParticipantActions({ actions, layout }: ParticipantActionsProps) {
  if (layout === 'buttons') {
    return (
      <div className="flex gap-2">
        {actions.map(action => (
          <Button
            key={action.label}
            onClick={action.onClick}
            variant={action.variant}
            size="icon"
          >
            <action.icon className="h-4 w-4" />
          </Button>
        ))}
      </div>
    )
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <MoreVertical className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        {actions.map(action => (
          <DropdownMenuItem
            key={action.label}
            onClick={action.onClick}
            className={cn(action.variant === 'destructive' && "text-destructive")}
          >
            <action.icon className="h-4 w-4 mr-2" />
            {action.label}
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
```

**Jeszcze lepiej - u≈ºyj Tailwind responsive utilities:**

```typescript
// ‚úÖ NAJLEPSZE - wykorzystanie Tailwind
<div className="hidden md:flex gap-2">
  {actions.map(action => (
    <Button key={action.label} onClick={action.onClick} variant={action.variant} size="icon">
      <action.icon className="h-4 w-4" />
    </Button>
  ))}
</div>

<div className="md:hidden">
  <DropdownMenu>
    {/* ... */}
  </DropdownMenu>
</div>
```

**Zalety:**
- DRY (Don't Repeat Yourself)
- ≈Åatwiejsze utrzymanie (zmiana w jednym miejscu)
- Mniejszy bundle size

##### C) Custom Hook dla edycji email

```typescript
// hooks/useParticipantEmailEdit.ts
export function useParticipantEmailEdit(participant: Participant) {
  const [isEditing, setIsEditing] = useState(false)
  const [emailValue, setEmailValue] = useState(participant.email || "")
  const { mutate: updateEmail } = useUpdateParticipantMutation()

  const handleStartEdit = useCallback(() => {
    setIsEditing(true)
    setEmailValue(participant.email || "")
  }, [participant.email])

  const handleSave = useCallback(async () => {
    if (!emailValue.trim()) {
      toast.error("Email nie mo≈ºe byƒá pusty")
      return
    }

    updateEmail(
      { participantId: participant.id, email: emailValue },
      {
        onSuccess: () => {
          setIsEditing(false)
          toast.success("Email zaktualizowany")
        },
        onError: (error) => {
          toast.error("B≈ÇƒÖd podczas aktualizacji email")
          console.error(error)
        }
      }
    )
  }, [participant.id, emailValue, updateEmail])

  const handleCancel = useCallback(() => {
    setIsEditing(false)
    setEmailValue(participant.email || "")
  }, [participant.email])

  return {
    isEditing,
    emailValue,
    setEmailValue,
    handleStartEdit,
    handleSave,
    handleCancel
  }
}
```

**Argumentacja:**
- Zgodnie z React 19 best practices: u≈ºywaj hook√≥w dla stateful logic
- ≈Åatwe testowanie (pure functions, mockowalne API calls)
- Reusability (mo≈ºe byƒá u≈ºyty w innych miejscach)

---

### 3. AddExclusionForm.tsx (239 linii) - üü° ≈öREDNI PRIORYTET

#### Struktura obecna:
- Formularz dodawania wyklucze≈Ñ z obs≈ÇugƒÖ dwustronnych blokad
- Walidacja Zod
- Obs≈Çuga duplikat√≥w

#### Zidentyfikowane problemy:

**1. Funkcja onSubmit ma 50 linii (powinno byƒá max 20)**

```typescript
const onSubmit = async (data: AddExclusionFormData) => {
  // 50 linii kodu - zbyt du≈ºo odpowiedzialno≈õci!
  // - walidacja duplikat√≥w (8 linii)
  // - toast notifications (10 linii)
  // - 2 API calls (22 linie)
  // - error handling (10 linii)
}
```

**2. Zod schema w komponencie (brak separacji)**

```typescript
// Linie 22-52 - 30 linii schematu w komponencie
const addExclusionSchema = z.object({
  fromParticipantId: z.string().min(1, "Wybierz uczestnika"),
  // ...
}).refine(/* custom validation */)
```

Powinno byƒá w osobnym pliku `schemas/exclusion.schema.ts`

**3. Dwa identyczne API calls (primary + reverse exclusion)**

```typescript
// Linie 100-109 - pierwszy API call
const { error: primaryError } = await supabase
  .from("exclusions")
  .insert({...})

// Linie 110-121 - drugi identyczny API call
const { error: reverseError } = await supabase
  .from("exclusions")
  .insert({...})
```

**4. Walidacja duplikat√≥w tylko po stronie klienta**

```typescript
// Linie 75-79
const isExclusionDuplicate = (from: string, to: string) => {
  return existingExclusions.some(...)
}
```

Brak walidacji na backendzie - ryzyko race conditions

#### Rekomendowane wzorce refaktoryzacji:

##### A) Service Layer Pattern

**Przed:**
```typescript
// Ca≈Ça logika API w komponencie
const onSubmit = async (data) => {
  const { error: primaryError } = await supabase.from("exclusions").insert(...)
  const { error: reverseError } = await supabase.from("exclusions").insert(...)
  // ...
}
```

**Po:**
```typescript
// services/exclusion.service.ts
export class ExclusionService {
  static async addBidirectionalExclusion(
    groupId: string,
    fromParticipantId: string,
    toParticipantId: string
  ) {
    const [primaryResult, reverseResult] = await Promise.all([
      supabase.from("exclusions").insert({
        group_id: groupId,
        from_participant: fromParticipantId,
        to_participant: toParticipantId
      }),
      supabase.from("exclusions").insert({
        group_id: groupId,
        from_participant: toParticipantId,
        to_participant: fromParticipantId
      })
    ])

    if (primaryResult.error) throw new ExclusionError(primaryResult.error.message)
    if (reverseResult.error) throw new ExclusionError(reverseResult.error.message)

    return { primary: primaryResult.data, reverse: reverseResult.data }
  }

  static async validateExclusion(
    groupId: string,
    fromParticipantId: string,
    toParticipantId: string
  ): Promise<boolean> {
    const { data, error } = await supabase
      .from("exclusions")
      .select("id")
      .eq("group_id", groupId)
      .eq("from_participant", fromParticipantId)
      .eq("to_participant", toParticipantId)
      .single()

    return !!data
  }
}

// W komponencie - proste wywo≈Çanie
const onSubmit = async (data: AddExclusionFormData) => {
  try {
    await ExclusionService.addBidirectionalExclusion(
      groupId,
      data.fromParticipantId,
      data.toParticipantId
    )
    toast.success("Wykluczenie dodane")
    onExclusionAdded()
  } catch (error) {
    toast.error(error.message)
  }
}
```

**Zalety:**
- DRY (jedna metoda zamiast duplikacji)
- ≈Åatwiejsze testowanie (mockowanie service)
- Reusability (mo≈ºe byƒá u≈ºyty w innych miejscach)
- Separacja concerns (logika biznesowa oddzielona od UI)

##### B) Schema Separation

**Przed:**
```typescript
// W komponencie - 30 linii
const addExclusionSchema = z.object({
  fromParticipantId: z.string().min(1, "Wybierz uczestnika"),
  toParticipantId: z.string().min(1, "Wybierz uczestnika"),
  isBidirectional: z.boolean().default(false)
}).refine(
  (data) => data.fromParticipantId !== data.toParticipantId,
  {
    message: "Uczestnik nie mo≈ºe wykluczyƒá samego siebie",
    path: ["toParticipantId"]
  }
)
```

**Po:**
```typescript
// schemas/exclusion.schema.ts
export const addExclusionSchema = z.object({
  fromParticipantId: z.string().min(1, "Wybierz uczestnika"),
  toParticipantId: z.string().min(1, "Wybierz uczestnika"),
  isBidirectional: z.boolean().default(false)
}).refine(
  (data) => data.fromParticipantId !== data.toParticipantId,
  {
    message: "Uczestnik nie mo≈ºe wykluczyƒá samego siebie",
    path: ["toParticipantId"]
  }
)

export type AddExclusionFormData = z.infer<typeof addExclusionSchema>

// W komponencie - import
import { addExclusionSchema, type AddExclusionFormData } from "@/schemas/exclusion.schema"

const form = useForm<AddExclusionFormData>({
  resolver: zodResolver(addExclusionSchema)
})
```

**Argumentacja:**
- Zgodnie ze strukturƒÖ projektu (istnieje folder schemas, ale nie jest konsekwentnie u≈ºywany)
- Reusability (schema mo≈ºe byƒá u≈ºyty w API endpoints, testach)
- Separacja concerns (walidacja oddzielona od UI)

##### C) Custom Hook + React Query

```typescript
// hooks/useAddExclusion.ts
export function useAddExclusion(groupId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: AddExclusionFormData) => {
      return ExclusionService.addBidirectionalExclusion(
        groupId,
        data.fromParticipantId,
        data.toParticipantId
      )
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['exclusions', groupId] })
      toast.success("Wykluczenie zosta≈Ço dodane")
    },
    onError: (error: Error) => {
      toast.error(error.message || "B≈ÇƒÖd podczas dodawania wykluczenia")
    }
  })
}

// W komponencie - bardzo prosty kod
export function AddExclusionForm({ groupId }: Props) {
  const form = useForm<AddExclusionFormData>({
    resolver: zodResolver(addExclusionSchema)
  })

  const { mutate: addExclusion, isPending } = useAddExclusion(groupId)

  const onSubmit = (data: AddExclusionFormData) => {
    addExclusion(data)
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* formularz */}
      </form>
    </Form>
  )
}
```

**Technika:** Service Layer + Thin Controller Pattern

**Zalety:**
- Komponent ma tylko odpowiedzialno≈õƒá UI
- Logika biznesowa w service layer
- Automatyczne cache invalidation przez React Query
- ≈Åatwe testowanie ka≈ºdej warstwy osobno

---

### 4. GroupView.tsx (215 linii) - üü¢ NISKI PRIORYTET (ju≈º dobrze zrefaktorowany!)

#### Struktura obecna:
- G≈Ç√≥wny kontener widoku grupy
- Orkiestracja 5 sekcji (Header, Participants, Exclusions, Draw, Results)
- ZarzƒÖdzanie 5 modalami
- React 19 useOptimistic dla instant UI updates

#### Zidentyfikowane problemy:

**1. Nadmierna ilo≈õƒá custom hooks (9 hooks)**
```typescript
const groupData = useGroupData(groupId)
const participants = useParticipants(groupId)
const exclusions = useExclusions(groupId)
const drawLogic = useDraw(groupId)
const modalState = useModalState()
const viewModel = useGroupViewModel(groupData, participants)
const handlers = useGroupViewHandlers(groupData, modalState)
// + 2x useOptimistic
```

To sugeruje, ≈ºe komponent robi zbyt du≈ºo (ale jest to ju≈º dobry refactoring!)

**2. Props drilling**
Handlers przekazywane do wszystkich child components:
```typescript
<ParticipantsList
  onParticipantAdded={handlers.onParticipantAdded}
  onParticipantUpdated={handlers.onParticipantUpdated}
  onParticipantDeleted={handlers.onParticipantDeleted}
  onEditParticipant={handlers.onEditParticipant}
  onDeleteParticipant={handlers.onDeleteParticipant}
  onCopyParticipantToken={handlers.onCopyParticipantToken}
/>
```

**3. ZarzƒÖdzanie auth state w useEffect**
```typescript
useEffect(() => {
  const getSession = async () => {
    const { data: { session } } = await supabase.auth.getSession()
    setSession(session)
  }
  getSession()
}, [])
```

#### Rekomendowane wzorce refaktoryzacji:

##### A) Context API dla modal√≥w (eliminacja props drilling)

**Przed:**
```typescript
// Props drilling przez 3 poziomy
<GroupView>
  <ParticipantsList
    onEdit={openEditModal}
    onDelete={openDeleteModal}
    onCopy={openCopyModal}
  />
</GroupView>
```

**Po:**
```typescript
// contexts/GroupModalsContext.tsx
interface GroupModalsContextValue {
  editModal: ModalState
  deleteModal: ModalState
  copyModal: ModalState
  openEditModal: (participant: Participant) => void
  openDeleteModal: (participant: Participant) => void
  openCopyModal: (token: string) => void
}

export const GroupModalsProvider: React.FC<PropsWithChildren> = ({ children }) => {
  const [editModal, setEditModal] = useState<ModalState>({ isOpen: false })
  const [deleteModal, setDeleteModal] = useState<ModalState>({ isOpen: false })
  const [copyModal, setCopyModal] = useState<ModalState>({ isOpen: false })

  const openEditModal = useCallback((participant: Participant) => {
    setEditModal({ isOpen: true, data: participant })
  }, [])

  // ... inne funkcje

  const value = useMemo(() => ({
    editModal,
    deleteModal,
    copyModal,
    openEditModal,
    openDeleteModal,
    openCopyModal
  }), [editModal, deleteModal, copyModal, openEditModal, openDeleteModal, openCopyModal])

  return (
    <GroupModalsContext.Provider value={value}>
      {children}
    </GroupModalsContext.Provider>
  )
}

export const useGroupModals = () => {
  const context = useContext(GroupModalsContext)
  if (!context) throw new Error("useGroupModals must be used within GroupModalsProvider")
  return context
}

// W komponencie GroupView
export function GroupView({ groupId }: Props) {
  return (
    <GroupModalsProvider>
      <GroupViewContent groupId={groupId} />
    </GroupModalsProvider>
  )
}

// W child component - zero props drilling!
function ParticipantCard({ participant }: Props) {
  const { openEditModal } = useGroupModals()

  return (
    <Card>
      <Button onClick={() => openEditModal(participant)}>Edytuj</Button>
    </Card>
  )
}
```

**Zalety:**
- Zero props drilling
- Cleaner API
- ≈Åatwiejsze dodawanie nowych modal√≥w
- Zgodne z React best practices

##### B) React 19 use() Hook dla auth

**Przed:**
```typescript
const [session, setSession] = useState<Session | null>(null)

useEffect(() => {
  const getSession = async () => {
    const { data: { session } } = await supabase.auth.getSession()
    setSession(session)
  }
  getSession()
}, [])
```

**Po:**
```typescript
// contexts/AuthContext.tsx
const sessionPromise = supabase.auth.getSession().then(res => res.data.session)

export function AuthProvider({ children }: PropsWithChildren) {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <AuthProviderInner>
        {children}
      </AuthProviderInner>
    </Suspense>
  )
}

function AuthProviderInner({ children }: PropsWithChildren) {
  const session = use(sessionPromise) // React 19 feature!

  return (
    <AuthContext.Provider value={{ session }}>
      {children}
    </AuthContext.Provider>
  )
}

// W komponencie GroupView - proste u≈ºycie
function GroupView({ groupId }: Props) {
  const { session } = useAuth()
  const isCreator = session?.user?.id === groupData?.created_by

  // ...
}
```

**Technika:** React 19 use() hook + Suspense dla data fetching

**Argumentacja:**
- Projekt ju≈º u≈ºywa React 19, wiƒôc mo≈ºemy wykorzystaƒá najnowsze features
- Eliminuje potrzebƒô useState + useEffect
- Lepsze wsparcie dla Suspense i concurrent rendering
- Zgodne z React 19 guidelines z `CLAUDE.md`

##### C) Render Props Pattern dla sekcji

**Przed:**
```typescript
// Zagnie≈ºd≈ºone komponenty z wieloma props
<ParticipantsSection
  participants={participants}
  isCreator={isCreator}
  canEdit={canEdit}
  onEdit={onEdit}
  onDelete={onDelete}
  onCopy={onCopy}
/>
```

**Po:**
```typescript
// Render props dla wiƒôkszej kontroli
<GroupView.Section
  title="Uczestnicy"
  icon={Users}
  render={({ permissions }) => (
    <ParticipantsList
      participants={participants}
      permissions={permissions}
    />
  )}
/>

// Implementacja
interface SectionProps {
  title: string
  icon: LucideIcon
  render: (context: SectionContext) => React.ReactNode
}

function Section({ title, icon: Icon, render }: SectionProps) {
  const { session } = useAuth()
  const { groupData } = useGroupData()

  const permissions = useMemo(() => ({
    canEdit: session?.user?.id === groupData?.created_by,
    canView: true,
    // ...
  }), [session, groupData])

  return (
    <Card>
      <CardHeader>
        <Icon className="h-5 w-5" />
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        {render({ permissions })}
      </CardContent>
    </Card>
  )
}
```

**Argumentacja:**
- Redukuje poziomy zagnie≈ºd≈ºenia
- ≈Åatwiejsza kontrola nad renderowaniem
- Flexibility - child decyduje jak u≈ºyƒá contextual data

**Pozytywne aspekty obecnej implementacji:**
- ‚úÖ Dobra separacja na hooks (refactoring ju≈º czƒô≈õciowo wykonany)
- ‚úÖ U≈ºycie React 19 useOptimistic dla lepszego UX
- ‚úÖ Czytelna struktura z jasnym podzia≈Çem na sekcje
- ‚úÖ TypeScript strict mode

**Rekomendacje (opcjonalne ulepszenia):**
- Rozwa≈ºyƒá Context API dla auth state zamiast useState + useEffect
- Stworzyƒá ModalsProvider dla lepszego zarzƒÖdzania modalami
- Wydzieliƒá authorization logic do useGroupPermissions hook
- Rozwa≈ºyƒá Compound Component Pattern dla sekcji
- Dodaƒá React.memo dla child components kt√≥re nie muszƒÖ siƒô re-renderowaƒá

---

### 5. ForgotPasswordForm.tsx (214 linii) - üü° ≈öREDNI PRIORYTET

#### Struktura obecna:
- Formularz resetowania has≈Ça
- 2 stany: form view i success view
- Walidacja Zod + React Hook Form

#### Zidentyfikowane problemy:

**1. Dwa ca≈Çkowicie r√≥≈ºne UI w jednym komponencie**

```typescript
// Linie 76-123: Success state (48 linii)
if (showSuccess) {
  return (
    <div>
      {/* Success message UI */}
    </div>
  )
}

// Linie 127-213: Form state (87 linii)
return (
  <form>
    {/* Form UI */}
  </form>
)
```

**2. Hardcoded inline SVG icons (48 linii)**

```typescript
// Linie 95-106: SVG dla success icon
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor">
  {/* 12 linii SVG */}
</svg>

// Linie 142-153: SVG dla info icon
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
  {/* 12 linii SVG */}
</svg>
```

Powinny byƒá w osobnych komponentach icon lub u≈ºywaƒá lucide-react

**3. Imperatywna nawigacja (anti-pattern)**

```typescript
// Linia 118
<Button onClick={() => window.location.href = "/login"}>
  Wr√≥ƒá do logowania
</Button>
```

**4. Brak reusability - duplikacja InfoBox pattern**

```typescript
// Linie 92-115 - Success info box
<div className="bg-pink-50 border border-pink-200 rounded-lg p-4 mb-6 text-left">
  {/* ... */}
</div>

// Linie 139-161 - Info box w formularzu
<div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6 flex items-start gap-3">
  {/* ... */}
</div>
```

#### Rekomendowane wzorce refaktoryzacji:

##### A) State Machine Pattern (Explicit State Management)

**Przed:**
```typescript
const [showSuccess, setShowSuccess] = useState(false)

const onSubmit = async (data) => {
  // ... API call
  setShowSuccess(true)
}

if (showSuccess) return <SuccessView />
return <FormView />
```

**Po:**
```typescript
// hooks/useForgotPasswordFlow.ts
type ForgotPasswordState = 'idle' | 'submitting' | 'success' | 'error'

interface ForgotPasswordFlowState {
  state: ForgotPasswordState
  email: string
  errorMessage?: string
}

export function useForgotPasswordFlow() {
  const [flowState, setFlowState] = useState<ForgotPasswordFlowState>({
    state: 'idle',
    email: ''
  })

  const submitEmail = useCallback(async (email: string) => {
    setFlowState(prev => ({ ...prev, state: 'submitting', email }))

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/reset-password`
      })

      if (error) throw error

      setFlowState(prev => ({ ...prev, state: 'success' }))
    } catch (error) {
      setFlowState(prev => ({
        ...prev,
        state: 'error',
        errorMessage: error.message
      }))
    }
  }, [])

  const reset = useCallback(() => {
    setFlowState({ state: 'idle', email: '' })
  }, [])

  return { flowState, submitEmail, reset }
}

// components/auth/ForgotPasswordForm.tsx
export function ForgotPasswordForm() {
  const { flowState, submitEmail } = useForgotPasswordFlow()

  if (flowState.state === 'success') {
    return <ForgotPasswordSuccess email={flowState.email} />
  }

  return (
    <ForgotPasswordFormView
      onSubmit={submitEmail}
      isSubmitting={flowState.state === 'submitting'}
      error={flowState.errorMessage}
    />
  )
}
```

**Zalety:**
- Explicit state management (≈Çatwe debugowanie)
- Type-safe transitions
- ≈Åatwiejsze testowanie flow (unit tests dla state machine)
- Zgodne z finite state machine pattern

##### B) Reusable Alert Component (Shadcn pattern)

**Przed:**
```typescript
// Duplikacja - r√≥≈ºne warianty info box√≥w w wielu miejscach
<div className="bg-pink-50 border border-pink-200 rounded-lg p-4 mb-6 text-left">
  <svg>{/* icon */}</svg>
  <h3>Tytu≈Ç</h3>
  <p>Opis</p>
</div>
```

**Po:**
```typescript
// components/ui/alert.tsx (Shadcn pattern)
const alertVariants = cva(
  "relative w-full rounded-lg border p-4",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive",
        success: "border-green-200 bg-green-50 text-green-900",
        info: "border-blue-200 bg-blue-50 text-blue-900",
        warning: "border-yellow-200 bg-yellow-50 text-yellow-900"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
)

export interface AlertProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof alertVariants> {}

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
)

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5 ref={ref} className={cn("mb-1 font-medium leading-none tracking-tight", className)} {...props} />
  )
)

const AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("text-sm [&_p]:leading-relaxed", className)} {...props} />
  )
)

// U≈ºycie w komponencie
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert"
import { CheckCircle2, Info } from "lucide-react"

<Alert variant="success">
  <CheckCircle2 className="h-4 w-4" />
  <AlertTitle>Email wys≈Çany!</AlertTitle>
  <AlertDescription>
    Link do resetowania has≈Ça zosta≈Ç wys≈Çany na adres {email}
  </AlertDescription>
</Alert>

<Alert variant="info">
  <Info className="h-4 w-4" />
  <AlertTitle>Wskaz√≥wka</AlertTitle>
  <AlertDescription>
    Sprawd≈∫ folder spam je≈õli nie widzisz wiadomo≈õci
  </AlertDescription>
</Alert>
```

**Technika:** Component composition zgodnie z Shadcn/ui patterns

**Zalety:**
- Reusable component (u≈ºycie w ca≈Çej aplikacji)
- Sp√≥jny design system
- Accessibility (role="alert")
- Zgodne z Shadcn/ui guidelines z `CLAUDE.md`

##### C) Lucide React Icons zamiast inline SVG

**Przed:**
```typescript
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
  <polyline points="20 6 9 17 4 12"></polyline>
</svg>
```

**Po:**
```typescript
import { CheckCircle2, Info, AlertCircle } from "lucide-react"

<CheckCircle2 className="h-16 w-16 text-success" />
<Info className="h-5 w-5 text-info" />
<AlertCircle className="h-5 w-5 text-destructive" />
```

**Zalety:**
- Konsystencja (ca≈Ça aplikacja u≈ºywa lucide-react)
- Tree-shaking (tylko u≈ºywane ikony w bundle)
- ≈Åatwiejsza customizacja (className props)
- Lepszy TypeScript support

##### D) Astro Navigation API (zamiast window.location)

**Przed:**
```typescript
<Button onClick={() => window.location.href = "/login"}>
  Wr√≥ƒá do logowania
</Button>
```

**Po:**
```typescript
// U≈ºyj Astro View Transitions API
import { navigate } from 'astro:transitions/client'

<Button onClick={() => navigate('/login')}>
  Wr√≥ƒá do logowania
</Button>

// LUB je≈õli jeste≈õ w React component bez dostƒôpu do Astro API:
import { useNavigate } from '@/hooks/useNavigate'

function ForgotPasswordSuccess() {
  const navigate = useNavigate()

  return (
    <Button onClick={() => navigate('/login')}>
      Wr√≥ƒá do logowania
    </Button>
  )
}

// hooks/useNavigate.ts
export function useNavigate() {
  return useCallback((path: string) => {
    // Check if Astro View Transitions are available
    if (typeof window !== 'undefined' && 'astroNavigate' in window) {
      window.astroNavigate(path)
    } else {
      window.location.href = path
    }
  }, [])
}
```

**Argumentacja:**
- Zgodnie z Astro 5 View Transitions API guidelines z `CLAUDE.md`
- P≈Çynne przej≈õcia miƒôdzy stronami (bez full page reload)
- Lepszy UX (SPA-like navigation)

##### E) Wydzielenie komponent√≥w

**Struktura plik√≥w po refaktoringu:**

```
src/components/auth/forgot-password/
‚îú‚îÄ‚îÄ ForgotPasswordForm.tsx         // Main orchestrator (30 linii)
‚îú‚îÄ‚îÄ ForgotPasswordFormView.tsx     // Form UI (80 linii)
‚îú‚îÄ‚îÄ ForgotPasswordSuccess.tsx      // Success UI (50 linii)
‚îî‚îÄ‚îÄ useForgotPasswordFlow.ts       // Business logic hook (50 linii)
```

**ForgotPasswordForm.tsx (orchestrator):**

```typescript
// Main component - tylko routing miƒôdzy states
export function ForgotPasswordForm() {
  const { flowState, submitEmail } = useForgotPasswordFlow()

  switch (flowState.state) {
    case 'success':
      return <ForgotPasswordSuccess email={flowState.email} />

    case 'idle':
    case 'submitting':
    case 'error':
    default:
      return (
        <ForgotPasswordFormView
          onSubmit={submitEmail}
          isSubmitting={flowState.state === 'submitting'}
          error={flowState.errorMessage}
        />
      )
  }
}
```

**Zalety ca≈Çego refactoringu:**
- Komponenty majƒÖ max 80 linii (zgodnie z best practices)
- Separation of concerns (UI, logic, state management)
- ≈Åatwiejsze testowanie (ka≈ºdy plik osobno)
- Reusability (Alert component w ca≈Çej aplikacji)

---

## üìã WSP√ìLNE PROBLEMY I ROZWIƒÑZANIA

### Problem 1: Violation of Single Responsibility Principle (4/5 plik√≥w)

**Wystƒôpuje w:**
- WishlistEditor.tsx
- ParticipantCard.tsx
- AddExclusionForm.tsx
- ForgotPasswordForm.tsx

**RozwiƒÖzanie:**
Zastosuj **Separation of Concerns Pattern**:

```typescript
// ‚ùå PRZED - wszystko w jednym
function Component() {
  // State management (10 linii)
  // API calls (20 linii)
  // Event handlers (30 linii)
  // Validation logic (15 linii)
  // JSX (100 linii)
}

// ‚úÖ PO - separacja odpowiedzialno≈õci
function ComponentContainer() {
  const logic = useComponentLogic()  // Custom hook
  return <ComponentPresenter {...logic} />
}

function ComponentPresenter(props) {
  // Tylko JSX, zero logiki
}

// hooks/useComponentLogic.ts
function useComponentLogic() {
  // Ca≈Ça logika biznesowa
}

// services/component.service.ts
class ComponentService {
  // API calls
}
```

---

### Problem 2: Duplikacja kodu (3/5 plik√≥w)

**Wystƒôpuje w:**
- ParticipantCard.tsx (mobile/desktop)
- AddExclusionForm.tsx (2 API calls)
- ForgotPasswordForm.tsx (info boxes)

**RozwiƒÖzanie:**
Zastosuj **DRY Principle** + **Abstraction**:

```typescript
// ‚ùå PRZED - duplikacja
<div className="hidden md:flex">{/* buttons */}</div>
<div className="md:hidden">{/* dropdown with same actions */}</div>

// ‚úÖ PO - abstrakcja
const actions = [...]
<ResponsiveActions actions={actions} />
```

---

### Problem 3: Brak separacji prezentacji od logiki (5/5 plik√≥w)

**Wystƒôpuje we wszystkich plikach**

**RozwiƒÖzanie:**
Zastosuj **Container/Presenter Pattern**:

```typescript
// Container = Smart Component (logika)
// Presenter = Dumb Component (UI)

function SmartComponent(props) {
  const logic = useBusinessLogic()
  return <DumbComponent {...props} {...logic} />
}

function DumbComponent({ data, handlers }) {
  return <div>{/* Pure UI */}</div>
}
```

---

### Problem 4: Nadmierna z≈Ço≈ºono≈õƒá renderowania (4/5 plik√≥w)

**Wystƒôpuje w:**
- WishlistEditor.tsx (122 linie JSX)
- ParticipantCard.tsx (210 linii JSX)
- AddExclusionForm.tsx (warunki inline)
- GroupView.tsx (sekcje)

**RozwiƒÖzanie:**
Zastosuj **Component Composition**:

```typescript
// ‚ùå PRZED - monolityczny JSX
return (
  <div>
    {/* 200 linii JSX z warunkami */}
  </div>
)

// ‚úÖ PO - kompozycja ma≈Çych komponent√≥w
return (
  <ComponentLayout>
    <ComponentHeader />
    <ComponentContent />
    <ComponentFooter />
  </ComponentLayout>
)
```

**Zasada:** Ka≈ºdy komponent max 50-80 linii JSX

---

### Problem 5: Props drilling i tight coupling (3/5 plik√≥w)

**Wystƒôpuje w:**
- ParticipantCard.tsx (7 props)
- GroupView.tsx (handlers w d√≥≈Ç)
- WishlistEditor.tsx (7 props)

**RozwiƒÖzanie:**
Zastosuj **Context API**:

```typescript
// ‚ùå PRZED - props drilling
<Parent>
  <Child onEdit={onEdit} onDelete={onDelete} onCopy={onCopy} />
</Parent>

// ‚úÖ PO - Context API
<ActionProvider>
  <Parent>
    <Child />
  </Parent>
</ActionProvider>

function Child() {
  const { onEdit, onDelete, onCopy } = useActions()
  // Zero props drilling!
}
```

---

### Problem 6: Hardcoded values i inline code (3/5 plik√≥w)

**Wystƒôpuje w:**
- WishlistEditor.tsx (character limits, date formats)
- ForgotPasswordForm.tsx (inline SVG)
- ParticipantCard.tsx (magic numbers)

**RozwiƒÖzanie:**
Zastosuj **Constants + Utilities + Icons**:

```typescript
// ‚ùå PRZED
if (content.length > 10000) { ... }
<svg width="64" height="64">{/* ... */}</svg>

// ‚úÖ PO
// constants/wishlist.ts
export const WISHLIST_MAX_LENGTH = 10000
export const WISHLIST_WARNING_THRESHOLD = 9500

// W komponencie
import { WISHLIST_MAX_LENGTH } from '@/constants/wishlist'
import { CheckCircle } from 'lucide-react'

if (content.length > WISHLIST_MAX_LENGTH) { ... }
<CheckCircle className="h-16 w-16" />
```

---

## üéØ PRIORYTETY REFAKTORYZACJI

### üî¥ WYSOKI PRIORYTET (Technical Debt)

1. **WishlistEditor.tsx** (336 linii)
   - **Czas:** 8-12 godzin
   - **Pow√≥d:** Najwiƒôkszy technical debt, 7 r√≥≈ºnych odpowiedzialno≈õci
   - **Impact:** Wysoki (czƒôsto u≈ºywany komponent, trudny w utrzymaniu)
   - **Akcje:**
     - Wydziel WishlistEditorLocked (40 linii)
     - Wydziel WishlistEditorStats (60 linii)
     - Wydziel WishlistEditorAIGenerator (80 linii)
     - Stw√≥rz useWishlistEditor hook (50 linii)
     - Stw√≥rz useWishlistStats hook (30 linii)

2. **ParticipantCard.tsx** (282 linie)
   - **Czas:** 6-8 godzin
   - **Pow√≥d:** Duplikacja kodu (46 linii), tight coupling
   - **Impact:** ≈öredni (u≈ºywany czƒôsto, ale mniej krytyczny)
   - **Akcje:**
     - Wydziel ParticipantActions component (60 linii)
     - Wydziel ParticipantEmailEditor (50 linii)
     - Stw√≥rz useParticipantEmailEdit hook (40 linii)
     - Usu≈Ñ duplikacjƒô mobile/desktop

---

### üü° ≈öREDNI PRIORYTET (Improvement)

3. **AddExclusionForm.tsx** (239 linii)
   - **Czas:** 4-6 godzin
   - **Pow√≥d:** D≈Çuga funkcja onSubmit (50 linii), brak service layer
   - **Impact:** Niski (rzadko zmieniany, ale wa≈ºna logika biznesowa)
   - **Akcje:**
     - Stw√≥rz ExclusionService class (80 linii)
     - Przenie≈õ schema do schemas/exclusion.schema.ts
     - Stw√≥rz useAddExclusion hook (40 linii)

4. **ForgotPasswordForm.tsx** (214 linii)
   - **Czas:** 4-5 godzin
   - **Pow√≥d:** Dwa r√≥≈ºne UI w jednym, inline SVG
   - **Impact:** Niski (rzadko u≈ºywany feature)
   - **Akcje:**
     - Wydziel ForgotPasswordSuccess component (50 linii)
     - Stw√≥rz Alert reusable component (60 linii)
     - Stw√≥rz useForgotPasswordFlow hook (50 linii)
     - Zamie≈Ñ inline SVG na lucide-react

---

### üü¢ NISKI PRIORYTET (Optional Enhancement)

5. **GroupView.tsx** (215 linii)
   - **Czas:** 3-4 godziny
   - **Pow√≥d:** Ju≈º dobrze zrefaktorowany, tylko drobne poprawki
   - **Impact:** Bardzo niski (kod czytelny, dobrze zorganizowany)
   - **Akcje (opcjonalne):**
     - Stw√≥rz GroupModalsProvider context
     - U≈ºyj React 19 use() hook dla auth
     - Dodaj React.memo dla child components

---

## üõ†Ô∏è WSP√ìLNE WZORCE DO ZASTOSOWANIA

### 1. Custom Hooks (wszystkie komponenty)

**Zgodnie z React 19 guidelines - oddziel logikƒô od UI:**

```typescript
// hooks/
‚îú‚îÄ‚îÄ useWishlistEditor.ts
‚îú‚îÄ‚îÄ useWishlistStats.ts
‚îú‚îÄ‚îÄ useParticipantEmailEdit.ts
‚îú‚îÄ‚îÄ useAddExclusion.ts
‚îú‚îÄ‚îÄ useForgotPasswordFlow.ts
‚îî‚îÄ‚îÄ useGroupPermissions.ts
```

**Best practices:**
- Jeden hook = jedna odpowiedzialno≈õƒá
- Prefix "use" dla React hooks
- Return object zamiast array (czytelniejsze)
- TypeScript strict mode

---

### 2. Service Layer (komponenty z API calls)

**Zgodnie z clean architecture:**

```typescript
// services/
‚îú‚îÄ‚îÄ wishlist.service.ts
‚îú‚îÄ‚îÄ participant.service.ts
‚îú‚îÄ‚îÄ exclusion.service.ts
‚îî‚îÄ‚îÄ auth.service.ts
```

**Pattern:**
```typescript
export class WishlistService {
  static async updateWishlist(participantId: string, content: string) {
    const { data, error } = await supabase
      .from('wishes')
      .update({ content })
      .eq('participant_id', participantId)

    if (error) throw new WishlistError(error.message)
    return data
  }
}
```

**Zalety:**
- DRY (reusability)
- ≈Åatwe testowanie (mockowanie)
- Separacja concerns (logika biznesowa oddzielona od UI)

---

### 3. Schema Separation (komponenty z formularzami)

**Zgodnie ze strukturƒÖ projektu:**

```typescript
// schemas/
‚îú‚îÄ‚îÄ wishlist.schema.ts
‚îú‚îÄ‚îÄ participant.schema.ts
‚îú‚îÄ‚îÄ exclusion.schema.ts
‚îî‚îÄ‚îÄ auth.schema.ts
```

**Pattern:**
```typescript
// schemas/exclusion.schema.ts
export const addExclusionSchema = z.object({
  fromParticipantId: z.string().min(1),
  toParticipantId: z.string().min(1),
  isBidirectional: z.boolean().default(false)
}).refine(...)

export type AddExclusionFormData = z.infer<typeof addExclusionSchema>
```

**Zalety:**
- Reusability (w API endpoints, testach)
- Sp√≥jno≈õƒá walidacji (frontend + backend)
- Type safety (TypeScript inference)

---

### 4. Micro-components (wszystkie komponenty)

**Zgodnie z React best practices:**

```typescript
// Zasada: Max 200 linii per component
// Preferuj kompozycjƒô z ma≈Çych komponent√≥w
```

**Przyk≈Çady micro-component√≥w do stworzenia:**

```
src/components/ui/
‚îú‚îÄ‚îÄ alert.tsx                    // Reusable alert box
‚îú‚îÄ‚îÄ stat-item.tsx                // Statystyki (znaki, s≈Çowa)
‚îú‚îÄ‚îÄ responsive-actions.tsx       // Responsywne akcje (buttons/dropdown)
‚îî‚îÄ‚îÄ save-indicator.tsx           // Wska≈∫nik autosave
```

**Best practices:**
- Single responsibility
- Composable (u≈ºywaj children, render props)
- Typeable (pe≈Çne TypeScript support)
- Testable (snapshot tests)

---

### 5. TypeScript Strict Mode (wszystkie pliki)

**Wszystkie komponenty u≈ºywajƒÖ TypeScript 5 - dodaj strict mode:**

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

**Zalety:**
- Catch errors at compile time
- Better IDE support
- Self-documenting code
- Zgodne z best practices z `CLAUDE.md`

---

## üìä METRYKI SUKCESU REFAKTORYZACJI

### Przed refaktoryzacjƒÖ:

| Komponent | LOC | Max funkcja | Liczba odpowiedzialno≈õci | Cyclomatic Complexity |
|-----------|-----|-------------|--------------------------|------------------------|
| WishlistEditor.tsx | 336 | 80 | 7 | Wysoka |
| ParticipantCard.tsx | 282 | 60 | 5 | ≈örednia |
| AddExclusionForm.tsx | 239 | 50 | 5 | ≈örednia |
| GroupView.tsx | 215 | 40 | 4 | Niska |
| ForgotPasswordForm.tsx | 214 | 40 | 3 | Niska |

### Po refaktoryzacji (cel):

| Komponent | LOC | Max funkcja | Liczba odpowiedzialno≈õci | Cyclomatic Complexity |
|-----------|-----|-------------|--------------------------|------------------------|
| WishlistEditor.tsx | 50-80 | 20 | 1-2 | Niska |
| ParticipantCard.tsx | 80-100 | 20 | 2 | Niska |
| AddExclusionForm.tsx | 80-100 | 20 | 2 | Niska |
| GroupView.tsx | 150-180 | 20 | 3 | Niska |
| ForgotPasswordForm.tsx | 30-50 | 15 | 1 | Niska |

### Kryteria sukcesu:

‚úÖ **Redukcja LOC o 40-60%** w g≈Ç√≥wnym komponencie
‚úÖ **Max 20 linii per funkcja** (zgodnie z Clean Code)
‚úÖ **Max 2 odpowiedzialno≈õci** per komponent
‚úÖ **100% TypeScript strict mode** coverage
‚úÖ **Zero duplikacji kodu**
‚úÖ **Cyclomatic complexity < 10** per funkcja
‚úÖ **Test coverage > 80%** dla logiki biznesowej

---

## üîÑ PROCES REFAKTORYZACJI (step-by-step)

### Faza 1: Przygotowanie (1-2 godziny)

1. **Setup test√≥w jednostkowych** dla istniejƒÖcych komponent√≥w
   ```bash
   npm run test:coverage -- WishlistEditor
   ```

2. **Stw√≥rz feature branch**
   ```bash
   git checkout -b refactor/wishlist-editor
   ```

3. **Dokumentuj obecne zachowanie** (screenshot tests, E2E)

---

### Faza 2: Refactoring (per komponent)

#### Krok 1: Wydziel logikƒô do hook√≥w (2-3h)

```typescript
// PRZED
function Component() {
  const [state, setState] = useState()
  const handleAction = async () => { /* logika */ }
  // ...
}

// PO
function Component() {
  const logic = useComponentLogic()
  return <ComponentPresenter {...logic} />
}
```

**Weryfikacja:** Testy jednostkowe dla hooka

---

#### Krok 2: Wydziel service layer (1-2h)

```typescript
// PRZED
const handleSave = async () => {
  const { data, error } = await supabase.from(...).insert(...)
  // ...
}

// PO
const handleSave = async () => {
  await ComponentService.save(...)
}
```

**Weryfikacja:** Testy integracyjne dla service

---

#### Krok 3: Podziel na micro-komponenty (3-4h)

```typescript
// PRZED
function Component() {
  return (
    <div>
      {/* 200 linii JSX */}
    </div>
  )
}

// PO
function Component() {
  return (
    <ComponentLayout>
      <ComponentHeader />
      <ComponentContent />
      <ComponentFooter />
    </ComponentLayout>
  )
}
```

**Weryfikacja:** Snapshot tests dla UI

---

#### Krok 4: Dodaj TypeScript strict mode (1h)

```typescript
// W≈ÇƒÖcz strict mode i napraw wszystkie b≈Çƒôdy
```

**Weryfikacja:** `tsc --noEmit`

---

### Faza 3: Testowanie (2-3 godziny)

1. **Unit tests** (hooki, services)
2. **Integration tests** (API calls)
3. **Component tests** (React Testing Library)
4. **E2E tests** (Playwright)
5. **Visual regression** (Storybook + Chromatic)

---

### Faza 4: Code Review & Merge (1-2 godziny)

1. **Self review** (checklist)
2. **Team review** (pull request)
3. **QA testing** (staging environment)
4. **Merge to main**

---

## üìö RESOURCES & DOCUMENTATION

### React 19 Best Practices
- [React 19 Documentation](https://react.dev)
- [use() Hook Guide](https://react.dev/reference/react/use)
- [useOptimistic() Hook Guide](https://react.dev/reference/react/useOptimistic)

### TypeScript 5
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/)
- [Strict Mode Guide](https://www.typescriptlang.org/tsconfig#strict)

### Astro 5
- [Astro Documentation](https://docs.astro.build)
- [View Transitions API](https://docs.astro.build/en/guides/view-transitions/)

### Design Patterns
- [Container/Presenter Pattern](https://www.patterns.dev/posts/presentational-container-pattern)
- [Compound Component Pattern](https://www.patterns.dev/posts/compound-pattern)
- [Service Layer Pattern](https://martinfowler.com/eaaCatalog/serviceLayer.html)

### Testing
- [Vitest Documentation](https://vitest.dev)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Playwright Documentation](https://playwright.dev)

---

## ‚úÖ CHECKLIST REFAKTORYZACJI

### Przed rozpoczƒôciem:
- [ ] Setup test√≥w jednostkowych
- [ ] Stw√≥rz feature branch
- [ ] Dokumentuj obecne zachowanie (screenshots, E2E)

### Podczas refactoringu:
- [ ] Wydziel logikƒô do custom hooks
- [ ] Stw√≥rz service layer dla API calls
- [ ] Podziel na micro-komponenty (max 200 LOC)
- [ ] Usu≈Ñ duplikacjƒô kodu
- [ ] Dodaj TypeScript strict mode
- [ ] Wydziel schema do osobnych plik√≥w
- [ ] Zamie≈Ñ inline SVG na lucide-react
- [ ] Zastosuj Context API gdzie potrzeba

### Po refaktoringu:
- [ ] Wszystkie testy przechodzƒÖ (unit, integration, E2E)
- [ ] Test coverage > 80%
- [ ] TypeScript build bez b≈Çƒôd√≥w
- [ ] ESLint bez warnings
- [ ] Prettier formatting OK
- [ ] Code review passed
- [ ] QA testing passed

---

## üéì WNIOSKI

### Co dzia≈Ça dobrze w obecnym kodzie:

‚úÖ **Wykorzystanie nowoczesnych technologii:**
- React 19 (useOptimistic)
- TypeScript 5
- Zod validation
- React Hook Form
- Supabase
- Shadcn/ui

‚úÖ **Dobra separacja plik√≥w:**
- Komponenty w dedykowanych folderach
- Hooki w osobnych plikach (czƒô≈õciowo)
- Struktura zgodna z best practices

‚úÖ **TypeScript usage:**
- Wszystkie komponenty typowane
- Interfaces dla props
- Type inference z Zod

### Co wymaga poprawy:

‚ùå **Naruszenie SOLID principles:**
- Single Responsibility Principle (wiƒôkszo≈õƒá komponent√≥w)
- Open/Closed Principle (hardcoded values)

‚ùå **Brak sp√≥jnej architektury:**
- Niekt√≥re komponenty u≈ºywajƒÖ hook√≥w, inne nie
- Brak service layer (API calls w komponentach)
- Schemas nie sƒÖ wydzielone konsekwentnie

‚ùå **Duplikacja kodu:**
- Mobile/desktop logic
- API calls
- UI patterns (info boxes, alerts)

‚ùå **Testability:**
- Komponenty trudne do testowania (zbyt wiele odpowiedzialno≈õci)
- Logika biznesowa w JSX

### Rekomendacje na przysz≈Ço≈õƒá:

1. **Ustan√≥w coding standards** (max LOC, max funkcja, odpowiedzialno≈õci)
2. **Wprowad≈∫ code review checklist** (DRY, SOLID, testability)
3. **Automatyzuj quality checks** (ESLint rules, TypeScript strict)
4. **Inwestuj w testy** (setup, CI/CD)
5. **Dokumentuj patterns** (ADR - Architecture Decision Records)

---

**Data utworzenia:** 4 listopada 2025
**Autor:** Claude Code (Sonnet 4.5)
**Wersja dokumentu:** 1.0
**Status:** Draft - wymaga review

---

## üìû KONTAKT & FEEDBACK

Je≈õli masz pytania dotyczƒÖce tej analizy lub potrzebujesz pomocy w implementacji refaktoryzacji, skontaktuj siƒô z zespo≈Çem developerskim.

**Next steps:**
1. Review tego dokumentu przez team
2. Priorytetyzacja refaktoringu (kt√≥ry komponent pierwszy?)
3. Estymacja czasu (story points)
4. Planning sprint refaktoryzacyjny

---

*Koniec dokumentu*