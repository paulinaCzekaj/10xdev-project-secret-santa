# Plan Implementacji Funkcjonalno≈õci "Elfa" - Secret Santa v1.1.0

**Wersja dokumentu**: 1.0
**Data utworzenia**: 2025-11-17
**Autor**: Plan wygenerowany na podstawie analizy wymaga≈Ñ
**Status**: Zatwierdzone do implementacji

---

## üìã PrzeglƒÖd

### Cel
Implementacja opcjonalnej roli "Elf" (Pomocnik) w aplikacji Secret Santa, umo≈ºliwiajƒÖcej przypisanie uczestnika grupy jako pomocnika dla innego uczestnika w procesie wyboru i zakupu prezentu.

### Kluczowe za≈Ço≈ºenia
1. **Opcjonalna funkcjonalno≈õƒá** - mo≈ºna utworzyƒá grupƒô bez elf√≥w
2. **Przypisanie rƒôczne** - tylko Tw√≥rca grupy przypisuje elf√≥w przed losowaniem
3. **Relacja 1:1** - jeden uczestnik mo≈ºe mieƒá maksymalnie jednego elfa, jeden elf pomaga maksymalnie jednej osobie
4. **Przypisanie przed losowaniem** - role elf√≥w sƒÖ ustawiane przed uruchomieniem losowania i stajƒÖ siƒô niemutowalne po losowaniu
5. **Jednokierunkowe wykluczenie** - je≈õli A jest elfem dla B, to B nie mo≈ºe wylosowaƒá A (ale A mo≈ºe wylosowaƒá B)
6. **Pe≈Çny dostƒôp dla elfa** - elf zalogowany widzi pe≈Çny wynik losowania osoby, kt√≥rej pomaga
7. **Uprawnienia edycji** - elf z kontem mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga
8. **Oddzielny tracking** - dostƒôp elfa jest ≈õledzony osobno w `elf_accessed_at`

### User Story US-016

**ID**: US-016
**Tytu≈Ç**: Rola Elfa - pomocnika w grupie Secret Santa
**Opis**: Jako Tw√≥rca grupy, chcƒô m√≥c przypisaƒá uczestnikowi pomocnika (Elfa), kt√≥ry bƒôdzie pomaga≈Ç w wyborze prezentu, majƒÖc dostƒôp do wyniku losowania tej osoby.

**Kryteria akceptacji**:
1. W formularzu dodawania uczestnika znajduje siƒô opcjonalny select "Elf dla uczestnika"
2. Tw√≥rca mo≈ºe wybraƒá, dla kt√≥rego uczestnika nowa osoba bƒôdzie elfem
3. Tw√≥rca mo≈ºe edytowaƒá przypisanie elfa do momentu rozpoczƒôcia losowania
4. Po losowaniu przypisania elf√≥w sƒÖ niemutowalne
5. W li≈õcie uczestnik√≥w widoczny jest badge "üßù Elf dla: [Imiƒô]" dla elf√≥w
6. Uczestnik, kt√≥ry ma przypisanego elfa, widzi informacjƒô "Tw√≥j pomocnik: [Imiƒô] üßù"
7. Elf zalogowany widzi przycisk "Zobacz wynik [Imiƒô] üßù" na stronie swojego wyniku
8. Po klikniƒôciu elf jest przekierowywany na `/groups/[groupId]/elf-result`
9. Elf widzi pe≈Çny wynik osoby, kt√≥rej pomaga: kogo wylosowa≈Ça, jej listƒô ≈ºycze≈Ñ, bud≈ºet
10. Elf z kontem mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga (do daty zako≈Ñczenia)
11. System automatycznie tworzy wykluczenie: osoba z elfem nie mo≈ºe wylosowaƒá swojego elfa
12. System trackuje moment otwarcia wyniku przez elfa w kolumnie `elf_accessed_at`

---

## üóÑÔ∏è ETAP 1: Rozszerzenie Bazy Danych

### 1.1. Nowa migracja SQL

**Plik**: `supabase/migrations/20251117000001_add_elf_functionality.sql`

```sql
-- Migration: Add Elf functionality to Secret Santa
-- Version: 1.1.0
-- Date: 2025-11-17
-- Description: Adds elf_for_participant_id column to participants table
--              for assigning helper role and tracking elf access

BEGIN;

-- Add elf_for_participant_id column to participants table
ALTER TABLE participants
ADD COLUMN elf_for_participant_id BIGINT NULL;

-- Add foreign key constraint
ALTER TABLE participants
ADD CONSTRAINT fk_elf_for_participant
FOREIGN KEY (elf_for_participant_id)
REFERENCES participants(id)
ON DELETE SET NULL;

-- Add check constraint: participant cannot be elf for themselves
ALTER TABLE participants
ADD CONSTRAINT different_elf_participant
CHECK (
  id != elf_for_participant_id
  OR elf_for_participant_id IS NULL
);

-- Add unique constraint: one participant can have max one elf per group
CREATE UNIQUE INDEX unique_elf_assignment_per_group
ON participants(group_id, elf_for_participant_id)
WHERE elf_for_participant_id IS NOT NULL;

-- Add index for efficient elf lookups
CREATE INDEX participants_elf_for_idx
ON participants(elf_for_participant_id);

-- Add column for tracking when elf accessed the result
ALTER TABLE participants
ADD COLUMN elf_accessed_at TIMESTAMPTZ NULL;

-- Add index for elf access tracking
CREATE INDEX participants_elf_accessed_at_idx
ON participants(elf_accessed_at);

-- Add comment explaining the elf relationship
COMMENT ON COLUMN participants.elf_for_participant_id IS
  'ID of the participant this user is helping as an elf. NULL if not an elf.';

COMMENT ON COLUMN participants.elf_accessed_at IS
  'Timestamp when the elf first accessed the result of the participant they are helping.';

COMMIT;
```

### 1.2. Zmiana w logice wyklucze≈Ñ

Wykluczenia elf√≥w bƒôdƒÖ obs≈Çugiwane automatycznie w `DrawService.buildExclusionMap()` bez dodatkowych wpis√≥w w tabeli `exclusion_rules`. To sƒÖ "niejawne wykluczenia" generowane on-the-fly podczas walidacji i losowania.

**Uzasadnienie**:
- Nie za≈õmiecamy tabeli exclusion_rules automatycznymi wpisami
- ≈Åatwiejsza walidacja (wystarczy sprawdziƒá `elf_for_participant_id`)
- Mniej zapyta≈Ñ do bazy podczas losowania

---

## üîß ETAP 2: Warstwa Serwisowa (Backend)

### 2.1. ParticipantService - rozszerzenie

**Plik**: `src/lib/services/participant.service.ts`

#### 2.1.1. Rozszerzenie DTO

```typescript
interface ParticipantDTO {
  id: number;
  group_id: number;
  user_id: string | null;
  name: string;
  email: string | null;
  access_token: string;
  result_viewed_at: string | null;
  created_at: string;

  // Nowe pola dla Elfa
  elf_for_participant_id: number | null;
  elf_for_participant_name: string | null; // z JOIN
  elf_accessed_at: string | null;
}

interface ParticipantViewModel {
  id: number;
  name: string;
  email: string | null;
  hasWishlist: boolean;
  hasViewedResult: boolean;
  isCreator: boolean;
  accessToken: string;
  resultViewedAt: string | null;

  // Nowe pola dla Elfa
  elfForParticipantId: number | null;
  elfForParticipantName: string | null;
  isElfForSomeone: boolean;  // czy jest elfem
  hasElf: boolean;            // czy ma przypisanego elfa
  elfName: string | null;     // imiƒô swojego elfa
  elfAccessedAt: string | null;
}
```

#### 2.1.2. Modyfikacja getGroupParticipants()

```typescript
static async getGroupParticipants(
  groupId: number,
  userId: string
): Promise<ParticipantViewModel[]> {
  const { data, error } = await supabase
    .from('participants')
    .select(`
      id,
      name,
      email,
      access_token,
      result_viewed_at,
      elf_for_participant_id,
      elf_accessed_at,
      elf_for:participants!elf_for_participant_id(id, name),
      has_elf:participants!inner(id, name, elf_for_participant_id),
      wishes(id),
      groups!inner(creator_id)
    `)
    .eq('group_id', groupId)
    .order('created_at', { ascending: true });

  if (error) throw error;

  return data.map(p => ({
    id: p.id,
    name: p.name,
    email: p.email,
    hasWishlist: p.wishes.length > 0,
    hasViewedResult: p.result_viewed_at !== null,
    isCreator: p.groups.creator_id === userId,
    accessToken: p.access_token,
    resultViewedAt: p.result_viewed_at,

    // Elf fields
    elfForParticipantId: p.elf_for_participant_id,
    elfForParticipantName: p.elf_for?.name || null,
    isElfForSomeone: p.elf_for_participant_id !== null,
    hasElf: p.has_elf.some(h => h.elf_for_participant_id === p.id),
    elfName: p.has_elf.find(h => h.elf_for_participant_id === p.id)?.name || null,
    elfAccessedAt: p.elf_accessed_at,
  }));
}
```

#### 2.1.3. Modyfikacja addParticipantToGroup()

```typescript
static async addParticipantToGroup(
  groupId: number,
  name: string,
  email: string | null,
  elfForParticipantId: number | null = null
): Promise<ParticipantDTO> {
  // Walidacja email uniqueness (existing code)
  // ...

  // Walidacja elf assignment
  if (elfForParticipantId !== null) {
    await this.validateElfAssignment(groupId, elfForParticipantId);
  }

  const { data, error } = await supabase
    .from('participants')
    .insert({
      group_id: groupId,
      name,
      email,
      elf_for_participant_id: elfForParticipantId,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}
```

#### 2.1.4. Modyfikacja updateParticipant()

```typescript
static async updateParticipant(
  participantId: number,
  updates: {
    name?: string;
    email?: string | null;
    elfForParticipantId?: number | null;
  }
): Promise<void> {
  const participant = await this.getParticipantWithGroupInfo(participantId);
  const drawCompleted = await this.checkDrawCompleted(participant.group_id);

  // Can only update elf assignment before draw
  if (updates.elfForParticipantId !== undefined && drawCompleted) {
    throw new Error('Cannot update elf assignment after draw has been completed');
  }

  // Validate elf assignment
  if (updates.elfForParticipantId !== null) {
    await this.validateElfAssignment(participant.group_id, updates.elfForParticipantId);
  }

  const updateData: any = {};
  if (updates.name !== undefined && !drawCompleted) updateData.name = updates.name;
  if (updates.email !== undefined) updateData.email = updates.email;
  if (updates.elfForParticipantId !== undefined) {
    updateData.elf_for_participant_id = updates.elfForParticipantId;
  }

  const { error } = await supabase
    .from('participants')
    .update(updateData)
    .eq('id', participantId);

  if (error) throw error;
}
```

#### 2.1.5. Nowa metoda validateElfAssignment()

```typescript
private static async validateElfAssignment(
  groupId: number,
  elfForParticipantId: number
): Promise<void> {
  // Check if elfForParticipantId exists in the same group
  const { data, error } = await supabase
    .from('participants')
    .select('id, elf_for_participant_id')
    .eq('group_id', groupId)
    .eq('id', elfForParticipantId)
    .single();

  if (error || !data) {
    throw new Error('Elf target participant not found in this group');
  }

  // Check if elfForParticipantId already has an elf (unique constraint)
  const { data: existingElf } = await supabase
    .from('participants')
    .select('id')
    .eq('group_id', groupId)
    .eq('elf_for_participant_id', elfForParticipantId)
    .maybeSingle();

  if (existingElf) {
    throw new Error('This participant already has an elf assigned');
  }
}
```

### 2.2. DrawService - modyfikacja

**Plik**: `src/lib/services/draw.service.ts`

#### 2.2.1. Rozszerzenie buildExclusionMap()

```typescript
private static buildExclusionMap(
  exclusions: ExclusionRuleDTO[],
  participants: ParticipantDTO[]
): Map<number, number[]> {
  const exclusionMap = new Map<number, number[]>();

  // Initialize map with empty arrays
  participants.forEach(p => exclusionMap.set(p.id, []));

  // Add explicit exclusion rules
  exclusions.forEach(rule => {
    const blocked = exclusionMap.get(rule.blocker_participant_id) || [];
    blocked.push(rule.blocked_participant_id);
    exclusionMap.set(rule.blocker_participant_id, blocked);
  });

  // Add implicit elf exclusions
  // If A is elf for B, then B cannot draw A
  participants.forEach(participant => {
    if (participant.elf_for_participant_id) {
      const elfForId = participant.elf_for_participant_id;
      const blocked = exclusionMap.get(elfForId) || [];

      // Add elf to the exclusion list of the person they're helping
      if (!blocked.includes(participant.id)) {
        blocked.push(participant.id);
        exclusionMap.set(elfForId, blocked);
      }
    }
  });

  return exclusionMap;
}
```

#### 2.2.2. Aktualizacja isDrawPossible()

```typescript
static isDrawPossible(
  participants: ParticipantDTO[],
  exclusions: ExclusionRuleDTO[]
): boolean {
  if (participants.length < 3) return false;

  // Build exclusion map including elf exclusions
  const exclusionMap = this.buildExclusionMap(exclusions, participants);

  // Validate that each participant has at least one possible receiver
  for (const participant of participants) {
    const excludedIds = exclusionMap.get(participant.id) || [];
    const possibleReceivers = participants.filter(p =>
      p.id !== participant.id &&
      !excludedIds.includes(p.id)
    );

    if (possibleReceivers.length === 0) {
      return false;
    }
  }

  return true;
}
```

#### 2.2.3. Nowa helper metoda getElfExclusionsForGroup()

```typescript
static getElfExclusionsForGroup(participants: ParticipantDTO[]): Array<{
  blocker_participant_id: number;
  blocker_name: string;
  blocked_participant_id: number;
  blocked_name: string;
}> {
  const elfExclusions: Array<any> = [];

  participants.forEach(participant => {
    if (participant.elf_for_participant_id) {
      const helpedParticipant = participants.find(
        p => p.id === participant.elf_for_participant_id
      );

      if (helpedParticipant) {
        elfExclusions.push({
          blocker_participant_id: helpedParticipant.id,
          blocker_name: helpedParticipant.name,
          blocked_participant_id: participant.id,
          blocked_name: participant.name,
        });
      }
    }
  });

  return elfExclusions;
}
```

### 2.3. ResultsService - nowe metody

**Plik**: `src/lib/services/results.service.ts`

#### 2.3.1. Nowa metoda getResultAsElf()

```typescript
interface ElfResultData {
  assignment: {
    receiverName: string;
    receiverWishlist: string | null;
    receiverWishlistHtml: string | null;
  };
  group: {
    id: number;
    name: string;
    budget: number;
    endDate: string;
  };
  helpedParticipant: {
    id: number;
    name: string;
  };
}

static async getResultAsElf(
  elfParticipantId: number,
  authUserId: string
): Promise<ElfResultData> {
  // Get elf participant with validation
  const { data: elf, error: elfError } = await supabase
    .from('participants')
    .select('id, name, user_id, elf_for_participant_id, group_id')
    .eq('id', elfParticipantId)
    .eq('user_id', authUserId)
    .single();

  if (elfError || !elf) {
    throw new Error('Elf participant not found or unauthorized');
  }

  if (!elf.elf_for_participant_id) {
    throw new Error('This participant is not an elf for anyone');
  }

  // Get the helped participant's assignment
  const { data: assignment, error: assignmentError } = await supabase
    .from('assignments')
    .select(`
      receiver_participant_id,
      receiver:participants!receiver_participant_id(
        name,
        wishes(wishlist)
      ),
      groups!inner(id, name, budget, end_date)
    `)
    .eq('giver_participant_id', elf.elf_for_participant_id)
    .single();

  if (assignmentError || !assignment) {
    throw new Error('Assignment not found for helped participant');
  }

  // Get helped participant info
  const { data: helped, error: helpedError } = await supabase
    .from('participants')
    .select('id, name')
    .eq('id', elf.elf_for_participant_id)
    .single();

  if (helpedError || !helped) {
    throw new Error('Helped participant not found');
  }

  const wishlist = assignment.receiver.wishes?.[0]?.wishlist || null;

  return {
    assignment: {
      receiverName: assignment.receiver.name,
      receiverWishlist: wishlist,
      receiverWishlistHtml: wishlist ? convertLinksToHtml(wishlist) : null,
    },
    group: {
      id: assignment.groups.id,
      name: assignment.groups.name,
      budget: assignment.groups.budget,
      endDate: assignment.groups.end_date,
    },
    helpedParticipant: {
      id: helped.id,
      name: helped.name,
    },
  };
}
```

#### 2.3.2. Nowa metoda trackElfAccess()

```typescript
static async trackElfAccess(participantId: number): Promise<void> {
  // Only set if not already set (first access)
  const { error } = await supabase
    .from('participants')
    .update({ elf_accessed_at: new Date().toISOString() })
    .eq('id', participantId)
    .is('elf_accessed_at', null);

  if (error) throw error;
}
```

#### 2.3.3. Rozszerzenie getResultForParticipant()

```typescript
// Add elf info to existing result
interface ResultData {
  // ... existing fields

  // New elf fields
  elf?: {
    id: number;
    name: string;
  } | null;
}

// In the query, add:
.select(`
  ...existing fields...,
  elf:participants!inner(id, name, elf_for_participant_id)
`)

// In the response mapping:
elf: data.elf.find(e => e.elf_for_participant_id === participantId) || null,
```

### 2.4. WishlistService - rozszerzenie uprawnie≈Ñ

**Plik**: `src/lib/services/wishlist.service.ts`

#### 2.4.1. Modyfikacja createOrUpdateWishlist()

```typescript
static async createOrUpdateWishlist(
  participantId: number,
  wishlist: string,
  authUserId: string | null,
  participantToken: string | null
): Promise<WishlistDTO> {
  // Get participant with group and elf info
  const { data: participant, error: participantError } = await supabase
    .from('participants')
    .select(`
      id,
      user_id,
      access_token,
      group_id,
      groups!inner(end_date),
      elf_participants:participants!elf_for_participant_id(id, user_id)
    `)
    .eq('id', participantId)
    .single();

  if (participantError || !participant) {
    throw new Error('Participant not found');
  }

  // Check if end_date has passed
  if (new Date(participant.groups.end_date) < new Date()) {
    throw new Error('END_DATE_PASSED');
  }

  // Authorization check
  let isAuthorized = false;
  let updatedByElf = false;

  // Check 1: Is authenticated user the participant?
  if (authUserId && participant.user_id === authUserId) {
    isAuthorized = true;
  }

  // Check 2: Does participant token match?
  if (participantToken && participant.access_token === participantToken) {
    isAuthorized = true;
  }

  // Check 3: Is authenticated user an elf for this participant?
  if (authUserId) {
    const elf = participant.elf_participants?.find(
      e => e.user_id === authUserId
    );
    if (elf) {
      isAuthorized = true;
      updatedByElf = true;
    }
  }

  if (!isAuthorized) {
    throw new Error('FORBIDDEN');
  }

  // Upsert wishlist
  const { data, error } = await supabase
    .from('wishes')
    .upsert({
      participant_id: participantId,
      wishlist,
      updated_at: new Date().toISOString(),
      // Optional: track if updated by elf
      // updated_by_elf: updatedByElf,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}
```

---

## üåê ETAP 3: API Endpoints

### 3.1. Rozszerzenie istniejƒÖcych endpoint√≥w

#### 3.1.1. PATCH `/api/participants/[participantId]`

**Plik**: `src/pages/api/participants/[participantId].ts`

```typescript
// Add to request body interface
interface UpdateParticipantRequest {
  name?: string;
  email?: string | null;
  elfForParticipantId?: number | null;
}

// In PATCH handler
export async function PATCH({ params, request, locals }: APIContext) {
  const participantId = parseInt(params.participantId!);
  const body: UpdateParticipantRequest = await request.json();

  // Existing auth checks...

  // Update participant with elf field
  await ParticipantService.updateParticipant(participantId, {
    name: body.name,
    email: body.email,
    elfForParticipantId: body.elfForParticipantId,
  });

  return new Response(JSON.stringify({ success: true }), {
    status: 200,
    headers: { 'Content-Type': 'application/json' },
  });
}
```

#### 3.1.2. GET `/api/groups/[groupId]/participants`

**Plik**: `src/pages/api/groups/[groupId]/participants.ts`

Response already includes elf fields through extended `ParticipantViewModel`. No changes needed, just ensure frontend receives the new fields.

#### 3.1.3. POST `/api/groups/[groupId]/participants`

**Plik**: `src/pages/api/groups/[groupId]/participants.ts`

```typescript
interface AddParticipantRequest {
  name: string;
  email: string | null;
  elfForParticipantId?: number | null; // NEW
}

// In POST handler
const participant = await ParticipantService.addParticipantToGroup(
  groupId,
  body.name,
  body.email,
  body.elfForParticipantId || null
);
```

### 3.2. Nowe endpointy

#### 3.2.1. GET `/api/participants/[participantId]/elf-result`

**Plik**: `src/pages/api/participants/[participantId]/elf-result.ts`

```typescript
import type { APIContext } from 'astro';
import { requireApiAuth } from '@/lib/utils/api-auth.utils';
import { ResultsService } from '@/lib/services/results.service';

export async function GET({ params, locals }: APIContext) {
  const participantId = parseInt(params.participantId!);

  // Require authentication (elf must be logged in)
  const userIdOrResponse = requireApiAuth({ locals });
  if (typeof userIdOrResponse !== 'string') {
    return userIdOrResponse;
  }
  const userId = userIdOrResponse;

  try {
    // Get result as elf (validates permissions internally)
    const result = await ResultsService.getResultAsElf(participantId, userId);

    // Track elf access
    await ResultsService.trackElfAccess(participantId);

    return new Response(JSON.stringify(result), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error: any) {
    if (error.message.includes('not an elf')) {
      return new Response(
        JSON.stringify({ error: 'NOT_AN_ELF' }),
        { status: 403, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (error.message.includes('unauthorized')) {
      return new Response(
        JSON.stringify({ error: 'UNAUTHORIZED' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'INTERNAL_SERVER_ERROR' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

#### 3.2.2. POST `/api/participants/[participantId]/track-elf-access`

**Plik**: `src/pages/api/participants/[participantId]/track-elf-access.ts`

```typescript
import type { APIContext } from 'astro';
import { requireApiAuth } from '@/lib/utils/api-auth.utils';
import { ResultsService } from '@/lib/services/results.service';

export async function POST({ params, locals }: APIContext) {
  const participantId = parseInt(params.participantId!);

  // Require authentication
  const userIdOrResponse = requireApiAuth({ locals });
  if (typeof userIdOrResponse !== 'string') {
    return userIdOrResponse;
  }

  try {
    await ResultsService.trackElfAccess(participantId);

    return new Response(
      JSON.stringify({ success: true }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error: any) {
    return new Response(
      JSON.stringify({ error: 'INTERNAL_SERVER_ERROR' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

---

## üé® ETAP 4: Frontend Components

### 4.1. Modyfikacje w widoku grupy

#### 4.1.1. ParticipantsList.tsx

**Plik**: `src/components/group/ParticipantsList.tsx`

```tsx
// Add new column for Role/Badge
<div className="grid grid-cols-[2fr_2fr_1fr_auto] gap-4 items-center">
  {/* Name column */}
  <div>
    <span className="font-medium">{participant.name}</span>
    {participant.isCreator && (
      <Badge variant="secondary" className="ml-2">
        üéÑ Tw√≥rca
      </Badge>
    )}
  </div>

  {/* Email column */}
  <div className="text-sm text-gray-600">{participant.email || '-'}</div>

  {/* Role column (NEW) */}
  <div className="flex flex-col gap-1">
    {participant.isElfForSomeone && (
      <Badge variant="outline" className="text-xs">
        üßù Elf dla: {participant.elfForParticipantName}
      </Badge>
    )}
    {participant.hasElf && (
      <span className="text-xs text-gray-500">
        Pomocnik: {participant.elfName} üßù
      </span>
    )}
  </div>

  {/* Actions column */}
  <div>...</div>
</div>
```

#### 4.1.2. AddParticipantForm.tsx

**Plik**: `src/components/group/AddParticipantForm.tsx`

```tsx
interface AddParticipantFormProps {
  participants: ParticipantViewModel[];
  onSubmit: (data: { name: string; email: string | null; elfForParticipantId: number | null }) => void;
  isDrawn: boolean;
}

export function AddParticipantForm({ participants, onSubmit, isDrawn }: AddParticipantFormProps) {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [elfForParticipantId, setElfForParticipantId] = useState<number | null>(null);

  // Filter participants who don't have an elf yet
  const availableForElf = participants.filter(p => !p.hasElf);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit({
      name,
      email: email || null,
      elfForParticipantId,
    });
    setName('');
    setEmail('');
    setElfForParticipantId(null);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        label="Imiƒô uczestnika"
        value={name}
        onChange={(e) => setName(e.target.value)}
        required
      />

      <Input
        label="Email (opcjonalnie)"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />

      {/* NEW: Elf assignment select */}
      <div className="space-y-2">
        <label className="text-sm font-medium flex items-center gap-2">
          Elf dla uczestnika (opcjonalnie)
          <Tooltip content="Elf bƒôdzie m√≥g≈Ç zobaczyƒá wynik losowania tej osoby i pom√≥c w wyborze prezentu">
            <InfoIcon className="w-4 h-4 text-gray-400" />
          </Tooltip>
        </label>
        <select
          value={elfForParticipantId || ''}
          onChange={(e) => setElfForParticipantId(e.target.value ? parseInt(e.target.value) : null)}
          disabled={isDrawn}
          className="w-full rounded-md border border-gray-300 px-3 py-2"
        >
          <option value="">Brak (nie jest elfem)</option>
          {availableForElf.map(p => (
            <option key={p.id} value={p.id}>
              {p.name}
            </option>
          ))}
        </select>
        {isDrawn && (
          <p className="text-xs text-gray-500">
            Nie mo≈ºna przypisywaƒá elf√≥w po losowaniu
          </p>
        )}
      </div>

      <Button type="submit">Dodaj uczestnika</Button>
    </form>
  );
}
```

#### 4.1.3. EditParticipantModal.tsx

**Plik**: `src/components/group/EditParticipantModal.tsx`

```tsx
// Add elfForParticipantId to state and form
const [elfForParticipantId, setElfForParticipantId] = useState<number | null>(
  participant.elfForParticipantId
);

// In JSX, add the same select as in AddParticipantForm
<div className="space-y-2">
  <label className="text-sm font-medium flex items-center gap-2">
    Elf dla uczestnika (opcjonalnie)
    <Tooltip content="...">
      <InfoIcon className="w-4 h-4 text-gray-400" />
    </Tooltip>
  </label>
  <select
    value={elfForParticipantId || ''}
    onChange={(e) => setElfForParticipantId(...)}
    disabled={isDrawn}
    className="..."
  >
    <option value="">Brak (nie jest elfem)</option>
    {availableForElf.map(p => (
      <option key={p.id} value={p.id}>{p.name}</option>
    ))}
  </select>
</div>

// In handleSave, include elfForParticipantId
await onSave({
  name,
  email,
  elfForParticipantId,
});
```

### 4.2. Modyfikacje w widoku wyniku

#### 4.2.1. ResultView.tsx

**Plik**: `src/components/result/ResultView.tsx`

```tsx
export function ResultView({ groupId, token, isAuthenticated }: ResultViewProps) {
  const { data, isLoading, error } = useResultData(groupId, token);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorComponent error={error} />;

  return (
    <div className="max-w-4xl mx-auto p-6 space-y-8">
      <ResultHeader group={data.group} />

      {/* NEW: Elf info box */}
      {data.elf && (
        <ElfInfoBox elfName={data.elf.name} />
      )}

      <ResultReveal />

      <AssignedPersonCard
        name={data.assignment.receiverName}
        wishlist={data.assignment.receiverWishlistHtml}
      />

      {/* NEW: Elf help section */}
      {data.participant.isElfForSomeone && (
        <ElfHelpSection
          helpedParticipantName={data.participant.elfForParticipantName!}
          helpedParticipantId={data.participant.elfForParticipantId!}
          groupId={groupId!}
        />
      )}

      <WishlistSection
        participantId={data.participant.id}
        initialWishlist={data.ownWishlist}
        canEdit={data.canEditWishlist}
        endDate={data.group.endDate}
      />
    </div>
  );
}
```

### 4.3. Nowe komponenty

#### 4.3.1. ElfHelpSection.tsx

**Plik**: `src/components/result/ElfHelpSection.tsx`

```tsx
interface ElfHelpSectionProps {
  helpedParticipantName: string;
  helpedParticipantId: number;
  groupId: number;
}

export function ElfHelpSection({
  helpedParticipantName,
  helpedParticipantId,
  groupId,
}: ElfHelpSectionProps) {
  return (
    <div className="bg-green-50 border border-green-200 rounded-lg p-6">
      <div className="flex items-start gap-4">
        <div className="text-4xl">üßù</div>
        <div className="flex-1 space-y-3">
          <h3 className="text-lg font-semibold text-green-900">
            Jeste≈õ elfem dla {helpedParticipantName}!
          </h3>
          <p className="text-sm text-green-800">
            Mo≈ºesz zobaczyƒá ich wynik losowania, aby pom√≥c w zakupie prezentu.
            Masz dostƒôp do informacji, kogo wylosowali oraz ich listy ≈ºycze≈Ñ.
          </p>
          <a
            href={`/groups/${groupId}/elf-result`}
            className="inline-flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition"
          >
            Zobacz wynik {helpedParticipantName} üßù
          </a>
        </div>
      </div>
    </div>
  );
}
```

#### 4.3.2. ElfInfoBox.tsx

**Plik**: `src/components/result/ElfInfoBox.tsx`

```tsx
interface ElfInfoBoxProps {
  elfName: string;
}

export function ElfInfoBox({ elfName }: ElfInfoBoxProps) {
  return (
    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
      <div className="flex items-center gap-3">
        <span className="text-2xl">üßù</span>
        <div>
          <p className="text-sm font-medium text-blue-900">
            Tw√≥j pomocnik: {elfName}
          </p>
          <p className="text-xs text-blue-700">
            {elfName} mo≈ºe zobaczyƒá kogo wylosowa≈Çe≈õ i pom√≥c Ci w wyborze prezentu
          </p>
        </div>
      </div>
    </div>
  );
}
```

#### 4.3.3. ElfResultView.tsx

**Plik**: `src/components/result/ElfResultView.tsx`

```tsx
interface ElfResultViewProps {
  groupId: number;
  participantId: number;
}

export function ElfResultView({ groupId, participantId }: ElfResultViewProps) {
  const { data, isLoading, error } = useElfResult(participantId);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorComponent error={error} />;

  return (
    <div className="max-w-4xl mx-auto p-6 space-y-8">
      {/* Banner */}
      <div className="bg-purple-50 border border-purple-200 rounded-lg p-6">
        <div className="flex items-start gap-4">
          <span className="text-4xl">üßù</span>
          <div>
            <h2 className="text-2xl font-bold text-purple-900 mb-2">
              Pomagasz: {data.helpedParticipant.name}
            </h2>
            <p className="text-sm text-purple-700">
              To jest widok pomocnika. Poni≈ºej widzisz kogo {data.helpedParticipant.name} wylosowa≈Ç/a
              i mo≈ºesz pom√≥c w znalezieniu idealnego prezentu.
            </p>
          </div>
        </div>
      </div>

      {/* Group info */}
      <ResultHeader group={data.group} />

      {/* Assigned person card */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold">
          {data.helpedParticipant.name} przygotowuje prezent dla:
        </h3>
        <AssignedPersonCard
          name={data.assignment.receiverName}
          wishlist={data.assignment.receiverWishlistHtml}
        />
      </div>

      {/* Back button */}
      <a
        href={`/groups/${groupId}/result`}
        className="inline-flex items-center gap-2 text-purple-600 hover:text-purple-800"
      >
        ‚Üê Wr√≥ƒá do mojego wyniku
      </a>
    </div>
  );
}
```

### 4.4. Nowe hooki

#### 4.4.1. useElfResult.ts

**Plik**: `src/hooks/useElfResult.ts`

```tsx
import { useState, useEffect } from 'react';

interface ElfResultData {
  assignment: {
    receiverName: string;
    receiverWishlist: string | null;
    receiverWishlistHtml: string | null;
  };
  group: {
    id: number;
    name: string;
    budget: number;
    endDate: string;
  };
  helpedParticipant: {
    id: number;
    name: string;
  };
}

export function useElfResult(participantId: number) {
  const [data, setData] = useState<ElfResultData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    async function fetchElfResult() {
      try {
        setIsLoading(true);

        const response = await fetch(`/api/participants/${participantId}/elf-result`, {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('session_token')}`,
          },
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to fetch elf result');
        }

        const result = await response.json();
        setData(result);

        // Track elf access
        await fetch(`/api/participants/${participantId}/track-elf-access`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('session_token')}`,
          },
        });
      } catch (err) {
        setError(err as Error);
      } finally {
        setIsLoading(false);
      }
    }

    fetchElfResult();
  }, [participantId]);

  return { data, isLoading, error };
}
```

---

## üõ£Ô∏è ETAP 5: Routing (Astro)

### 5.1. Nowa strona elf-result

**Plik**: `src/pages/groups/[groupId]/elf-result.astro`

```astro
---
import Layout from '@/layouts/Layout.astro';
import { ElfResultView } from '@/components/result/ElfResultView';

const { groupId } = Astro.params;
const user = Astro.locals.user;

// Require authentication
if (!user) {
  return Astro.redirect('/auth/signin?redirect=' + Astro.url.pathname);
}

// Get participant ID for this user in this group
const participant = await getParticipantByUserAndGroup(user.id, parseInt(groupId!));

if (!participant) {
  return Astro.redirect('/dashboard?error=not_participant');
}

// Check if user is an elf
if (!participant.elf_for_participant_id) {
  return Astro.redirect(`/groups/${groupId}/result?error=not_an_elf`);
}
---

<Layout title="Widok Elfa - Secret Santa">
  <ElfResultView
    groupId={parseInt(groupId!)}
    participantId={participant.id}
    client:load
  />
</Layout>
```

---

## üß™ ETAP 6: Testy

### 6.1. Testy jednostkowe (Vitest)

#### 6.1.1. DrawService.spec.ts

**Plik**: `tests/unit/DrawService.spec.ts`

```typescript
describe('DrawService - Elf Exclusions', () => {
  it('should exclude elf from being drawn by helped participant', () => {
    const participants = [
      { id: 1, name: 'Alice', elf_for_participant_id: null },
      { id: 2, name: 'Bob', elf_for_participant_id: 1 }, // Bob is elf for Alice
      { id: 3, name: 'Charlie', elf_for_participant_id: null },
    ];

    const exclusions = [];
    const exclusionMap = DrawService['buildExclusionMap'](exclusions, participants);

    // Alice should not be able to draw Bob (her elf)
    expect(exclusionMap.get(1)).toContain(2);
  });

  it('should allow elf to draw the helped participant', () => {
    const participants = [
      { id: 1, name: 'Alice', elf_for_participant_id: null },
      { id: 2, name: 'Bob', elf_for_participant_id: 1 },
      { id: 3, name: 'Charlie', elf_for_participant_id: null },
    ];

    const exclusions = [];
    const exclusionMap = DrawService['buildExclusionMap'](exclusions, participants);

    // Bob CAN draw Alice (he's her elf)
    expect(exclusionMap.get(2)).not.toContain(1);
  });

  it('should validate draw possibility with elf exclusions', () => {
    const participants = [
      { id: 1, name: 'Alice', elf_for_participant_id: null },
      { id: 2, name: 'Bob', elf_for_participant_id: 1 },
      { id: 3, name: 'Charlie', elf_for_participant_id: null },
    ];

    const exclusions = [];
    const isPossible = DrawService.isDrawPossible(participants, exclusions);

    expect(isPossible).toBe(true);
  });

  it('should detect impossible draw with combined elf and explicit exclusions', () => {
    const participants = [
      { id: 1, name: 'Alice', elf_for_participant_id: null },
      { id: 2, name: 'Bob', elf_for_participant_id: 1 },
      { id: 3, name: 'Charlie', elf_for_participant_id: null },
    ];

    // Alice cannot draw Charlie, Bob cannot draw Charlie
    // Bob is elf for Alice (Alice cannot draw Bob)
    // This leaves Alice with no valid receivers
    const exclusions = [
      { blocker_participant_id: 1, blocked_participant_id: 3 },
      { blocker_participant_id: 2, blocked_participant_id: 3 },
    ];

    const isPossible = DrawService.isDrawPossible(participants, exclusions);

    expect(isPossible).toBe(false);
  });
});
```

#### 6.1.2. ParticipantService.spec.ts

```typescript
describe('ParticipantService - Elf Validation', () => {
  it('should validate elf assignment in same group', async () => {
    await expect(
      ParticipantService.validateElfAssignment(1, 999)
    ).rejects.toThrow('not found in this group');
  });

  it('should prevent duplicate elf assignment', async () => {
    // Setup: participant 2 already has elf 3
    await expect(
      ParticipantService.validateElfAssignment(1, 2)
    ).rejects.toThrow('already has an elf');
  });
});
```

### 6.2. Testy E2E (Playwright)

#### 6.2.1. elf-workflow.spec.ts

**Plik**: `tests/e2e/elf-workflow.spec.ts`

```typescript
import { test, expect } from '@playwright/test';

test.describe('Elf Functionality', () => {
  test('creator can assign elf to participant', async ({ page }) => {
    // Login as creator
    await page.goto('/auth/signin');
    await page.fill('input[name="email"]', 'creator@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Create group
    await page.goto('/groups/new');
    await page.fill('input[name="name"]', 'Christmas 2025');
    await page.fill('input[name="budget"]', '100');
    await page.fill('input[name="endDate"]', '2025-12-25');
    await page.click('button[type="submit"]');

    // Add participant Alice
    await page.fill('input[name="participantName"]', 'Alice');
    await page.click('button:has-text("Dodaj uczestnika")');

    // Add participant Bob as elf for Alice
    await page.fill('input[name="participantName"]', 'Bob');
    await page.selectOption('select[name="elfForParticipantId"]', { label: 'Alice' });
    await page.click('button:has-text("Dodaj uczestnika")');

    // Verify badge
    await expect(page.locator('text=üßù Elf dla: Alice')).toBeVisible();
  });

  test('elf can view result of helped participant', async ({ page }) => {
    // Setup: group with drawn assignments, user is elf for Alice

    // Login as Bob (elf)
    await page.goto('/auth/signin');
    await page.fill('input[name="email"]', 'bob@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Go to result page
    await page.goto('/groups/1/result');

    // Click elf help button
    await page.click('a:has-text("Zobacz wynik Alice üßù")');

    // Verify on elf result page
    await expect(page.locator('h2:has-text("Pomagasz: Alice")')).toBeVisible();

    // Verify can see Alice's assignment
    await expect(page.locator('text=Alice przygotowuje prezent dla:')).toBeVisible();
  });

  test('helped participant cannot draw their elf', async ({ page }) => {
    // Setup: group with Alice (has Bob as elf) + Charlie
    // Execute draw

    // Verify: Alice's assignment is NOT Bob
    const assignment = await getAssignment(aliceId);
    expect(assignment.receiver_participant_id).not.toBe(bobId);
  });

  test('elf access is tracked separately', async ({ page }) => {
    // Login as elf, view result
    await page.goto('/groups/1/elf-result');

    // Check database
    const participant = await getParticipant(bobId);
    expect(participant.elf_accessed_at).not.toBeNull();
  });

  test('elf with account can edit wishlist of helped participant', async ({ page }) => {
    // Login as Bob (elf for Alice)
    await page.goto('/auth/signin');
    await page.fill('input[name="email"]', 'bob@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Go to elf result page
    await page.goto('/groups/1/elf-result');

    // Navigate to Alice's wishlist (if editable from elf view)
    // Or go directly to Alice's participant page
    await page.goto(`/groups/1/result?token=${aliceToken}`);

    // Edit wishlist
    await page.fill('textarea[name="wishlist"]', 'Updated by elf: Books, Coffee');
    await page.waitForTimeout(2000); // Auto-save

    // Verify saved
    const wishlist = await getWishlist(aliceParticipantId);
    expect(wishlist.wishlist).toContain('Updated by elf');
  });
});
```

---

## üìù ETAP 7: Dokumentacja

### 7.1. Aktualizacja PRD

**Plik**: `.ai/prd.md`

Dodaƒá nowƒÖ sekcjƒô **3.6. Funkcjonalno≈õƒá Elfa (Wersja 1.1)**:

```markdown
### 3.6. Funkcjonalno≈õƒá Elfa (Wersja 1.1)

- Tw√≥rca grupy mo≈ºe przypisaƒá uczestnikowi rolƒô "Elfa" dla innego uczestnika
- Przypisanie odbywa siƒô rƒôcznie podczas dodawania lub edycji uczestnika
- Jeden uczestnik mo≈ºe mieƒá maksymalnie jednego elfa (relacja 1:1)
- Przypisanie elfa jest mo≈ºliwe tylko przed losowaniem
- Po losowaniu role elf√≥w stajƒÖ siƒô niemutowalne
- System automatycznie tworzy jednokierunkowe wykluczenie: osoba, kt√≥ra ma elfa, nie mo≈ºe go wylosowaƒá
- Elf mo≈ºe wylosowaƒá osobƒô, kt√≥rej pomaga
- Elf zalogowany widzi na stronie swojego wyniku przycisk "Zobacz wynik [Imiƒô] üßù"
- Po klikniƒôciu elf jest przekierowywany na `/groups/[groupId]/elf-result`
- Elf widzi pe≈Çny wynik losowania osoby, kt√≥rej pomaga: kogo wylosowa≈Ça, jej listƒô ≈ºycze≈Ñ, bud≈ºet grupy
- Elf z kontem mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga (do daty zako≈Ñczenia wydarzenia)
- Osoba, kt√≥ra ma elfa, widzi informacjƒô "Tw√≥j pomocnik: [Imiƒô] üßù"
- System oddzielnie trackuje dostƒôp elfa w kolumnie `elf_accessed_at`
```

Dodaƒá nowƒÖ User Story **US-016**:

```markdown
- ID: US-016
- Tytu≈Ç: Rola Elfa - pomocnika w grupie Secret Santa
- Opis: Jako Tw√≥rca grupy, chcƒô m√≥c przypisaƒá uczestnikowi pomocnika (Elfa), kt√≥ry bƒôdzie pomaga≈Ç w wyborze prezentu, majƒÖc dostƒôp do wyniku losowania tej osoby.
- Kryteria akceptacji:
  1. W formularzu dodawania uczestnika znajduje siƒô opcjonalny select "Elf dla uczestnika"
  2. Tw√≥rca mo≈ºe wybraƒá, dla kt√≥rego uczestnika nowa osoba bƒôdzie elfem
  3. Tw√≥rca mo≈ºe edytowaƒá przypisanie elfa do momentu rozpoczƒôcia losowania
  4. Po losowaniu przypisania elf√≥w sƒÖ niemutowalne
  5. W li≈õcie uczestnik√≥w widoczny jest badge "üßù Elf dla: [Imiƒô]" dla elf√≥w
  6. Uczestnik, kt√≥ry ma przypisanego elfa, widzi informacjƒô "Tw√≥j pomocnik: [Imiƒô] üßù"
  7. Elf zalogowany widzi przycisk "Zobacz wynik [Imiƒô] üßù" na stronie swojego wyniku
  8. Po klikniƒôciu elf jest przekierowywany na `/groups/[groupId]/elf-result`
  9. Elf widzi pe≈Çny wynik osoby, kt√≥rej pomaga: kogo wylosowa≈Ça, jej listƒô ≈ºycze≈Ñ, bud≈ºet
  10. Elf z kontem mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga (do daty zako≈Ñczenia)
  11. System automatycznie tworzy wykluczenie: osoba z elfem nie mo≈ºe wylosowaƒá swojego elfa
  12. System trackuje moment otwarcia wyniku przez elfa w kolumnie `elf_accessed_at`
```

Zaktualizowaƒá sekcjƒô **4.3. Funkcjonalno≈õci planowane na wersjƒô 1.1**:

```markdown
### 4.3. Funkcjonalno≈õci zrealizowane w wersji 1.1

- ‚úÖ **AI-generowanie listu do Miko≈Çaja** (zrealizowane)
- ‚úÖ **Rola Elfa** - pomocnik uczestnika z dostƒôpem do jego wyniku losowania (zrealizowane)

### 4.4. Funkcjonalno≈õci planowane na przysz≈Çe wersje

- System powiadomie≈Ñ (e-mail, push)
- Formalny system zaprosze≈Ñ do grupy
- Wbudowany czat grupowy
- Mo≈ºliwo≈õƒá ponownego losowania
- Zaawansowane role u≈ºytkownik√≥w (wsp√≥≈Çorganizator)
- Obs≈Çuga wielu walut
```

Dodaƒá do sekcji **7. Wymagania Techniczne (Wersja 1.1)**:

```markdown
### 7.6. Struktura bazy danych dla Elfa

**Rozszerzenie tabeli `participants`:**

```sql
ALTER TABLE participants ADD COLUMN elf_for_participant_id BIGINT NULL;
ALTER TABLE participants ADD COLUMN elf_accessed_at TIMESTAMPTZ NULL;
```

**Constrainty:**
- Foreign key: `elf_for_participant_id -> participants.id`
- Check: `id != elf_for_participant_id`
- Unique: `(group_id, elf_for_participant_id)` WHERE NOT NULL

**Indeksy:**
- `participants_elf_for_idx` na `elf_for_participant_id`
- `participants_elf_accessed_at_idx` na `elf_accessed_at`
```

### 7.2. README - User Documentation

Dodaƒá sekcjƒô o roli Elfa w dokumentacji u≈ºytkownika (je≈õli istnieje README lub docs):

```markdown
## Rola Elfa üßù

Elf to opcjonalna rola pomocnika w grupie Secret Santa. Tw√≥rca grupy mo≈ºe przypisaƒá uczestnikowi rolƒô elfa dla innego uczestnika.

### Kiedy u≈ºywaƒá Elfa?

- Pomaganie starszym osobom w obs≈Çudze aplikacji
- Wsparcie w wyborze prezentu dla trudnego odbiorcy
- U≈Çatwienie komunikacji w grupach miƒôdzypokoleniowych

### Uprawnienia Elfa:

- ‚úÖ Widzi pe≈Çny wynik losowania osoby, kt√≥rej pomaga
- ‚úÖ Mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ tej osoby (je≈õli ma konto)
- ‚úÖ Ma dostƒôp do informacji o bud≈ºecie i dacie zako≈Ñczenia
- ‚ùå Nie mo≈ºe zmieniƒá przypisania po losowaniu
- ‚ùå Nie widzi wynik√≥w innych uczestnik√≥w

### Jak przypisaƒá Elfa?

1. Przy dodawaniu uczestnika wybierz opcjƒô "Elf dla uczestnika"
2. Wybierz z listy osobƒô, kt√≥rej bƒôdzie pomaga≈Ç
3. Mo≈ºesz zmieniƒá przypisanie do momentu losowania
```

---

## üéØ ETAP 8: Walidacja i Bezpiecze≈Ñstwo

### 8.1. Walidacje biznesowe

**Checklist walidacji:**

- ‚úÖ Tylko creator mo≈ºe przypisywaƒá elf√≥w (`requireGroupOwner` middleware)
- ‚úÖ Tylko przed losowaniem mo≈ºna zmieniaƒá przypisania elf√≥w (check `drawCompleted`)
- ‚úÖ Jeden uczestnik = max 1 elf (unique constraint w bazie)
- ‚úÖ Elf i uczestnik muszƒÖ byƒá w tej samej grupie (`validateElfAssignment`)
- ‚úÖ Uczestnik nie mo≈ºe byƒá elfem sam dla siebie (check constraint w bazie)
- ‚úÖ Elf musi byƒá zalogowany aby zobaczyƒá wynik (`requireApiAuth`)
- ‚úÖ API waliduje czy u≈ºytkownik jest rzeczywi≈õcie elfem (`getResultAsElf` validates `elf_for_participant_id`)

### 8.2. Bezpiecze≈Ñstwo

**Security considerations:**

1. **Authorization checks:**
   - Endpoint `/api/participants/[id]/elf-result` wymaga Bearer token
   - Service `getResultAsElf()` waliduje: `participant.user_id === authUserId`
   - Service sprawdza: `participant.elf_for_participant_id IS NOT NULL`

2. **Token access:**
   - Niezarejestrowani elfowie (bez user_id) NIE mogƒÖ otworzyƒá `/elf-result`
   - Access token daje dostƒôp tylko do w≈Çasnego wyniku, nie do wyniku osoby, kt√≥rej elf pomaga
   - To wymusza rejestracjƒô dla elf√≥w, co jest po≈ºƒÖdane (accountability)

3. **Tracking:**
   - `elf_accessed_at` oddzielne od `result_viewed_at`
   - Pozwala rozr√≥≈ºniƒá: czy uczestnik zobaczy≈Ç SW√ìJ wynik vs czy ELF zobaczy≈Ç wynik uczestnika

4. **Data exposure:**
   - Elf widzi tylko wynik osoby, kt√≥rej pomaga (nie wszystkich)
   - Nie ma endpointu "get all results for group" dla elfa
   - Elf nie widzi kto kogo wylosowa≈Ç (opr√≥cz osoby, kt√≥rej pomaga)

### 8.3. RLS (Row Level Security)

**Uwaga:** RLS obecnie wy≈ÇƒÖczone w development. Przed produkcjƒÖ trzeba w≈ÇƒÖczyƒá.

#### 8.3.1. Policy dla `participants` (elf read)

```sql
-- Elves can read participants in their groups
CREATE POLICY "elves_can_read_group_participants"
ON participants FOR SELECT
USING (
  -- Authenticated user is a participant in the same group
  group_id IN (
    SELECT group_id FROM participants
    WHERE user_id = auth.uid()
  )
);
```

#### 8.3.2. Policy dla `assignments` (elf read)

```sql
-- Elves can view assignment of participant they help
CREATE POLICY "elves_can_view_helped_participant_assignment"
ON assignments FOR SELECT
USING (
  -- Assignment belongs to participant the elf is helping
  giver_participant_id IN (
    SELECT elf_for_participant_id
    FROM participants
    WHERE user_id = auth.uid()
    AND elf_for_participant_id IS NOT NULL
  )
  OR
  -- Or it's the elf's own assignment
  giver_participant_id IN (
    SELECT id FROM participants WHERE user_id = auth.uid()
  )
);
```

#### 8.3.3. Policy dla `wishes` (elf read/write)

```sql
-- Elves can read wishlist of participant they help
CREATE POLICY "elves_can_read_helped_participant_wishlist"
ON wishes FOR SELECT
USING (
  participant_id IN (
    SELECT elf_for_participant_id
    FROM participants
    WHERE user_id = auth.uid()
    AND elf_for_participant_id IS NOT NULL
  )
  OR
  participant_id IN (
    SELECT id FROM participants WHERE user_id = auth.uid()
  )
);

-- Elves can update wishlist of participant they help
CREATE POLICY "elves_can_update_helped_participant_wishlist"
ON wishes FOR UPDATE
USING (
  participant_id IN (
    SELECT elf_for_participant_id
    FROM participants
    WHERE user_id = auth.uid()
    AND elf_for_participant_id IS NOT NULL
  )
  OR
  participant_id IN (
    SELECT id FROM participants WHERE user_id = auth.uid()
  )
);
```

---

## üì¶ Kolejno≈õƒá Implementacji

### Dzie≈Ñ 1: Baza danych + Serwisy
**Szacowany czas: 4-6h**

1. ‚úÖ Utworzyƒá migracjƒô `20251117000001_add_elf_functionality.sql`
2. ‚úÖ Uruchomiƒá migracjƒô lokalnie i sprawdziƒá constraints
3. ‚úÖ Rozszerzyƒá `ParticipantService` - DTO, ViewModel, metody
4. ‚úÖ Dodaƒá walidacjƒô `validateElfAssignment()`
5. ‚úÖ Testy jednostkowe dla `ParticipantService`

### Dzie≈Ñ 2: Logika losowania + ResultsService
**Szacowany czas: 4-6h**

1. ‚úÖ Modyfikowaƒá `DrawService.buildExclusionMap()` - dodaƒá elf exclusions
2. ‚úÖ Modyfikowaƒá `DrawService.isDrawPossible()` - uwzglƒôdniƒá elf√≥w
3. ‚úÖ Dodaƒá `DrawService.getElfExclusionsForGroup()`
4. ‚úÖ Testy jednostkowe dla `DrawService` z elfami
5. ‚úÖ Rozszerzyƒá `ResultsService` - `getResultAsElf()`, `trackElfAccess()`
6. ‚úÖ Testy jednostkowe dla `ResultsService`

### Dzie≈Ñ 3: API Endpoints
**Szacowany czas: 3-4h**

1. ‚úÖ Rozszerzyƒá `PATCH /api/participants/[participantId]` - elf field
2. ‚úÖ Rozszerzyƒá `POST /api/groups/[groupId]/participants` - elf field
3. ‚úÖ Utworzyƒá `GET /api/participants/[participantId]/elf-result`
4. ‚úÖ Utworzyƒá `POST /api/participants/[participantId]/track-elf-access`
5. ‚úÖ Testy API endpoints (np. Postman lub curl)

### Dzie≈Ñ 4: Frontend - Widok grupy
**Szacowany czas: 5-6h**

1. ‚úÖ Modyfikowaƒá `ParticipantsList.tsx` - dodaƒá kolumnƒô Role z badges
2. ‚úÖ Modyfikowaƒá `AddParticipantForm.tsx` - dodaƒá select elfa
3. ‚úÖ Modyfikowaƒá `EditParticipantModal.tsx` - dodaƒá select elfa
4. ‚úÖ Modyfikowaƒá `ParticipantCard.tsx` - mobile view z elfem
5. ‚úÖ Testowaƒá manualnie dodawanie/edycjƒô elf√≥w

### Dzie≈Ñ 5: Frontend - Widok wyniku + Routing
**Szacowany czas: 5-6h**

1. ‚úÖ Utworzyƒá `ElfHelpSection.tsx`
2. ‚úÖ Utworzyƒá `ElfInfoBox.tsx`
3. ‚úÖ Utworzyƒá `ElfResultView.tsx`
4. ‚úÖ Utworzyƒá hook `useElfResult.ts`
5. ‚úÖ Modyfikowaƒá `ResultView.tsx` - dodaƒá sekcje elfa
6. ‚úÖ Utworzyƒá stronƒô `/groups/[groupId]/elf-result.astro`
7. ‚úÖ Testowaƒá manualnie flow elfa

### Dzie≈Ñ 6: Testy E2E + Dokumentacja
**Szacowany czas: 4-5h**

1. ‚úÖ Napisaƒá testy E2E `elf-workflow.spec.ts`
2. ‚úÖ Uruchomiƒá wszystkie testy (unit + E2E)
3. ‚úÖ Naprawiƒá b≈Çƒôdy i edge cases
4. ‚úÖ Zaktualizowaƒá PRD - sekcja 3.6, US-016
5. ‚úÖ Zaktualizowaƒá README/docs
6. ‚úÖ Code review i refactoring

---

## ‚ö†Ô∏è Potencjalne Ryzyka

### 1. Algorytm losowania - z≈Ço≈ºono≈õƒá walidacji
**Ryzyko:** Dodanie wyklucze≈Ñ elf√≥w mo≈ºe zwiƒôkszyƒá liczbƒô przypadk√≥w niemo≈ºliwych do rozwiƒÖzania

**Mitigation:**
- Testy performance - mierzenie czasu wykonania z r√≥≈ºnƒÖ liczbƒÖ elf√≥w
- Timeout 15s jest wystarczajƒÖcy dla grup do 50 os√≥b
- Wy≈õwietlaƒá ostrze≈ºenie w UI gdy konfiguracja elf√≥w blokuje losowanie

### 2. UX confusion - u≈ºytkownicy nie rozumiejƒÖ roli elfa
**Ryzyko:** U≈ºytkownicy mogƒÖ nie zrozumieƒá czym r√≥≈ºni siƒô elf od zwyk≈Çego uczestnika

**Mitigation:**
- Tooltips przy select "Elf dla uczestnika"
- Jasne labele i opisy w UI
- Przyk≈Çady u≈ºycia w dokumentacji
- Onboarding tooltip przy pierwszym u≈ºyciu

### 3. Privacy concerns - elf widzi cudzy wynik
**Ryzyko:** U≈ºytkownicy mogƒÖ mieƒá obawy o prywatno≈õƒá

**Mitigation:**
- Wyra≈∫na informacja "Tw√≥j pomocnik: [Imiƒô] üßù" na stronie wyniku
- Dokumentacja wyja≈õniajƒÖca uprawnienia elfa
- Elf musi byƒá zalogowany (accountability)
- Tracking `elf_accessed_at` dla transparentno≈õci

### 4. Editing wishlist by elf - konflikt zmian
**Ryzyko:** Co je≈õli zar√≥wno uczestnik, jak i elf edytujƒÖ listƒô ≈ºycze≈Ñ jednocze≈õnie?

**Mitigation:**
- Auto-save z debounce (istniejƒÖce rozwiƒÖzanie)
- Last write wins (standard)
- Opcjonalnie: pokazaƒá timestamp "Ostatnia edycja: [data]"
- Opcjonalnie: dodaƒá info "Edytowane przez: [Imiƒô]" (wymaga kolumny `updated_by_elf`)

### 5. Performance - dodatkowe JOINy dla elf√≥w
**Ryzyko:** Query `getGroupParticipants` mo≈ºe byƒá wolniejszy z dodatkowymi JOIN dla elf√≥w

**Mitigation:**
- Indeksy na `elf_for_participant_id` (ju≈º dodane w migracji)
- Monitorowaƒá czas wykonania query
- Opcjonalnie: cache wynik√≥w dla grupy
- Dla du≈ºych grup (>100 os√≥b): rozwa≈ºyƒá denormalizacjƒô

---

## ‚úÖ Definition of Done

Funkcjonalno≈õƒá Elfa jest uko≈Ñczona gdy:

1. ‚úÖ Migracja bazy danych jest wykonana i zweryfikowana
2. ‚úÖ Wszystkie testy jednostkowe przechodzƒÖ (DrawService, ParticipantService, ResultsService)
3. ‚úÖ Wszystkie testy E2E przechodzƒÖ (elf-workflow.spec.ts)
4. ‚úÖ Tw√≥rca mo≈ºe przypisaƒá/edytowaƒá elfa w UI
5. ‚úÖ Elf widzi przycisk "Zobacz wynik [Imiƒô]" na swojej stronie wyniku
6. ‚úÖ Elf mo≈ºe otworzyƒá `/groups/[groupId]/elf-result` i zobaczyƒá wynik osoby, kt√≥rej pomaga
7. ‚úÖ Elf z kontem mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga
8. ‚úÖ Osoba z elfem widzi info "Tw√≥j pomocnik: [Imiƒô] üßù"
9. ‚úÖ Wykluczenie dzia≈Ça: osoba z elfem nie losuje swojego elfa
10. ‚úÖ Tracking `elf_accessed_at` dzia≈Ça poprawnie
11. ‚úÖ PRD jest zaktualizowane (sekcja 3.6, US-016)
12. ‚úÖ Dokumentacja u≈ºytkownika (README) zawiera info o elfach
13. ‚úÖ Code review przeprowadzone i zaaprobowane
14. ‚úÖ Deployment na dev/staging przebieg≈Ç pomy≈õlnie

---

## üìä Metryki Sukcesu (Post-Launch)

Po wdro≈ºeniu wersji 1.1 z funkcjonalno≈õciƒÖ Elfa bƒôdziemy monitorowaƒá:

1. **Wska≈∫nik adopcji:**
   - % grup kt√≥re u≈ºywajƒÖ elf√≥w
   - Cel: min. 20% nowych grup w pierwszym miesiƒÖcu

2. **Aktywno≈õƒá elf√≥w:**
   - % elf√≥w kt√≥rzy otworzyli wynik osoby, kt√≥rej pomagajƒÖ
   - Cel: min. 70% elf√≥w otwiera wynik

3. **Edycja przez elf√≥w:**
   - % wishlist edytowanych przez elf√≥w
   - Cel: min. 30% elf√≥w edytuje listƒô ≈ºycze≈Ñ

4. **Completion rate:**
   - % grup z elfami kt√≥re uko≈Ñczy≈Çy losowanie
   - Cel: identyczny jak grupy bez elf√≥w (99%+)

5. **Error rate:**
   - Liczba b≈Çƒôd√≥w zwiƒÖzanych z elfami
   - Cel: < 1% ≈ºƒÖda≈Ñ

6. **Feedback:**
   - Pozytywne opinie u≈ºytkownik√≥w o funkcjonalno≈õci
   - NPS score dla funkcji Elfa

---

## üîÑ Changelog Entry

**Version 1.1.0** - 2025-11-17

### Added
- **Rola Elfa**: Opcjonalna rola pomocnika w grupie Secret Santa
  - Tw√≥rca mo≈ºe przypisaƒá uczestnikowi rolƒô elfa dla innego uczestnika
  - Elf zalogowany widzi pe≈Çny wynik losowania osoby, kt√≥rej pomaga
  - Elf mo≈ºe edytowaƒá listƒô ≈ºycze≈Ñ osoby, kt√≥rej pomaga (je≈õli ma konto)
  - Automatyczne wykluczenie: osoba z elfem nie mo≈ºe wylosowaƒá swojego elfa
  - Nowy endpoint: `GET /api/participants/:id/elf-result`
  - Nowa strona: `/groups/[groupId]/elf-result`
  - Tracking dostƒôpu elfa w kolumnie `elf_accessed_at`

### Database
- Dodano kolumnƒô `elf_for_participant_id` do tabeli `participants`
- Dodano kolumnƒô `elf_accessed_at` do tabeli `participants`
- Dodano constrainty i indeksy dla relacji elf-uczestnik

### Technical
- Rozszerzono `DrawService.buildExclusionMap()` o wykluczenia elf√≥w
- Rozszerzono `ParticipantService` o metody zarzƒÖdzania elfami
- Dodano `ResultsService.getResultAsElf()` dla dostƒôpu elfa do wyniku
- Nowe komponenty: `ElfHelpSection`, `ElfInfoBox`, `ElfResultView`
- Nowy hook: `useElfResult`

---

**Koniec dokumentu**
