# Analiza z≈Ço≈ºono≈õci lib/ - 05.11.2025

## Executive Summary

Przeanalizowano wszystkie pliki w folderze `src/lib/` identyfikujƒÖc TOP 5 plik√≥w o najwiƒôkszej liczbie linii kodu (LOC) i potencjalnie wysokiej z≈Ço≈ºono≈õci. Pliki w lib/ to g≈Ç√≥wnie serwisy domenowe (Service Layer Pattern), kt√≥re enkapsulujƒÖ logikƒô biznesowƒÖ aplikacji Secret Santa. Dla ka≈ºdego z TOP 5 plik√≥w zaproponowano konkretne kierunki refaktoryzacji z wykorzystaniem wzorc√≥w projektowych i technik dopasowanych do stack technologicznego projektu (TypeScript, Supabase, Node.js).

---

## 1. TOP 5 plik√≥w o najwiƒôkszej liczbie LOC

### Ranking (malejƒÖco):

| #  | Plik                           | LOC | Kategoria | Ocena z≈Ço≈ºono≈õci |
|----|--------------------------------|-----|-----------|------------------|
| 1  | `participant.service.ts`       | 770 | Service   | ‚ö†Ô∏è Bardzo wysoka  |
| 2  | `group.service.ts`             | 651 | Service   | ‚ö†Ô∏è Bardzo wysoka  |
| 3  | `results.service.ts`           | 504 | Service   | ‚ö†Ô∏è Wysoka         |
| 4  | `wishlist.service.ts`          | 484 | Service   | ‚ö†Ô∏è Wysoka         |
| 5  | `exclusion-rule.service.ts`    | 420 | Service   | ‚ö†Ô∏è ≈örednia        |

**Inne znaczƒÖce pliki:**
- `draw.service.ts` - 326 linii (algorytm losowania - backtracking)
- `formatters.ts` - 221 linii (utility functions)
- `messages.ts` - 208 linii (s≈Çownik notyfikacji)

---

## 2. Szczeg√≥≈Çowa analiza i propozycje refaktoryzacji

### 1Ô∏è‚É£ participant.service.ts (770 linii)

**Lokalizacja:** `/home/user/secret-santa/src/lib/services/participant.service.ts`

#### üî¥ Zidentyfikowane problemy:

1. **God Service Pattern** - serwis obs≈Çuguje 11 r√≥≈ºnych operacji
   - CRUD uczestnik√≥w
   - Walidacje (authorization, email uniqueness, creator check)
   - Tracking (result access)
   - Queries pomocnicze (getParticipantWithGroupInfo)

2. **Powtarzana logika autoryzacji** - minimum 6 metod ma identycznƒÖ walidacjƒô
   - `checkDrawCompleted` - duplikowany w wielu miejscach
   - `checkUserIsGroupCreator` - mo≈ºna wydzieliƒá
   - `checkEmailUniqueness` - mo≈ºna generalizowaƒá

3. **Query repetition** - podobne zapytania Supabase w wielu metodach
   - Sprawdzanie assignments (draw completed) - 5 miejsc
   - Pobieranie group.creator_id - 4 miejsca
   - SELECT z JOINami - 2 miejsca

4. **Mixed concerns** - serwis miesza:
   - Logikƒô biznesowƒÖ (CRUD)
   - Walidacje
   - Queries pomocnicze
   - Tracking analytics

#### ‚úÖ Propozycje refaktoryzacji:

##### A) **Wydzielenie AuthorizationService**

**Priorytet:** üî• WYSOKI (eliminuje duplikacjƒô w 5+ serwisach)

```typescript
// services/authorizationService.ts
export class AuthorizationService {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Sprawdza czy u≈ºytkownik jest tw√≥rcƒÖ grupy
   * Reu≈ºywalne w: ParticipantService, ExclusionRuleService, GroupService
   */
  async isGroupCreator(userId: string, groupId: number): Promise<boolean> {
    const { data } = await this.supabase
      .from("groups")
      .select("creator_id")
      .eq("id", groupId)
      .single();

    return data?.creator_id === userId;
  }

  /**
   * Sprawdza czy losowanie zosta≈Ço przeprowadzone
   * Reu≈ºywalne w: ParticipantService, ExclusionRuleService, GroupService
   */
  async isDrawCompleted(groupId: number): Promise<boolean> {
    const { data } = await this.supabase
      .from("assignments")
      .select("id")
      .eq("group_id", groupId)
      .limit(1)
      .maybeSingle();

    return data !== null;
  }

  /**
   * Weryfikuje pe≈Çne uprawnienia do modyfikacji grupy
   * (tw√≥rca + losowanie nie wykonane)
   */
  async canModifyGroup(
    userId: string,
    groupId: number
  ): Promise<{ canModify: boolean; reason?: string }> {
    const isCreator = await this.isGroupCreator(userId, groupId);
    if (!isCreator) {
      return { canModify: false, reason: "FORBIDDEN" };
    }

    const isDrawn = await this.isDrawCompleted(groupId);
    if (isDrawn) {
      return { canModify: false, reason: "DRAW_COMPLETED" };
    }

    return { canModify: true };
  }
}

// U≈ºycie w ParticipantService
export class ParticipantService {
  constructor(
    private supabase: SupabaseClient,
    private authService: AuthorizationService // Dependency Injection
  ) {}

  async addParticipantToGroup(...) {
    // Zamiast 20+ linii walidacji:
    const { canModify, reason } = await this.authService.canModifyGroup(userId, groupId);
    if (!canModify) {
      throw new Error(reason);
    }
    // Reszta logiki...
  }
}
```

**Korzy≈õci:**
- ‚úÖ Eliminacja ~100 linii duplikacji w 5 serwisach
- ‚úÖ Single Responsibility - autoryzacja w jednym miejscu
- ‚úÖ ≈Åatwiejsze testy (mock AuthorizationService)
- ‚úÖ DRY - jedna implementacja logiki autoryzacji

**Wp≈Çyw:** Redukcja ~100 linii w ParticipantService, ~60 w GroupService, ~40 w ExclusionRuleService

---

##### B) **Podzia≈Ç na mniejsze serwisy (Service Composition)**

**Priorytet:** üü° ≈öREDNI

```typescript
// services/participant/participantCrudService.ts (~200 linii)
export class ParticipantCrudService {
  async create(...) { /* Tylko logika tworzenia */ }
  async update(...) { /* Tylko logika aktualizacji */ }
  async delete(...) { /* Tylko logika usuwania */ }
}

// services/participant/participantQueryService.ts (~150 linii)
export class ParticipantQueryService {
  async getById(...) { /* Queries */ }
  async getByGroupId(...) { /* Queries */ }
  async getWithGroupInfo(...) { /* Queries z JOINami */ }
}

// services/participant/participantValidationService.ts (~100 linii)
export class ParticipantValidationService {
  async validateEmailUniqueness(...) { /* Walidacje */ }
  async validateNotCreator(...) { /* Walidacje */ }
}

// services/participant/participantTrackingService.ts (~80 linii)
export class ParticipantTrackingService {
  async trackResultAccess(...) { /* Analytics */ }
}

// services/participant/index.ts (Facade Pattern)
export class ParticipantService {
  private crud: ParticipantCrudService;
  private query: ParticipantQueryService;
  private validation: ParticipantValidationService;
  private tracking: ParticipantTrackingService;

  constructor(supabase: SupabaseClient) {
    this.crud = new ParticipantCrudService(supabase);
    this.query = new ParticipantQueryService(supabase);
    this.validation = new ParticipantValidationService(supabase);
    this.tracking = new ParticipantTrackingService(supabase);
  }

  // Deleguje do odpowiednich serwis√≥w
  async addParticipantToGroup(...) {
    await this.validation.validateEmailUniqueness(...);
    return this.crud.create(...);
  }
}
```

**Struktura katalog√≥w:**
```
src/lib/services/
  ‚îú‚îÄ‚îÄ participant/
  ‚îÇ   ‚îú‚îÄ‚îÄ participantCrudService.ts       (~200 linii)
  ‚îÇ   ‚îú‚îÄ‚îÄ participantQueryService.ts      (~150 linii)
  ‚îÇ   ‚îú‚îÄ‚îÄ participantValidationService.ts (~100 linii)
  ‚îÇ   ‚îú‚îÄ‚îÄ participantTrackingService.ts   (~80 linii)
  ‚îÇ   ‚îî‚îÄ‚îÄ index.ts                        (~100 linii - Facade)
  ‚îú‚îÄ‚îÄ group/
  ‚îÇ   ‚îú‚îÄ‚îÄ groupCrudService.ts
  ‚îÇ   ‚îú‚îÄ‚îÄ groupQueryService.ts
  ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
  ‚îî‚îÄ‚îÄ authorizationService.ts
```

**Korzy≈õci:**
- ‚úÖ Single Responsibility - ka≈ºdy serwis ma jednƒÖ odpowiedzialno≈õƒá
- ‚úÖ ≈Åatwiejsze testowanie (mniejsze, focused testy)
- ‚úÖ Mo≈ºliwo≈õƒá reu≈ºycia (np. QueryService w r√≥≈ºnych kontekstach)
- ‚úÖ Lepsza organizacja kodu (folder per domain)

**Wp≈Çyw:** Lepszy SRP, lepsza organizacja, ≈Çatwiejsze testy

---

##### C) **Repository Pattern dla Supabase queries**

**Priorytet:** üîµ NISKI (du≈ºa zmiana architektoniczna)

```typescript
// repositories/participantRepository.ts
export class ParticipantRepository {
  constructor(private supabase: SupabaseClient) {}

  async findById(id: number): Promise<ParticipantDTO | null> {
    const { data, error } = await this.supabase
      .from("participants")
      .select("*")
      .eq("id", id)
      .single();

    if (error) return null;
    return data;
  }

  async findWithGroupInfo(id: number): Promise<ParticipantWithGroupDTO | null> {
    const { data, error } = await this.supabase
      .from("participants")
      .select(`
        *,
        group:groups (
          id,
          creator_id,
          name,
          end_date
        )
      `)
      .eq("id", id)
      .single();

    if (error) return null;
    return data;
  }

  async findByGroupId(groupId: number): Promise<ParticipantDTO[]> {
    const { data } = await this.supabase
      .from("participants")
      .select("*")
      .eq("group_id", groupId)
      .order("created_at", { ascending: true });

    return data || [];
  }

  async create(data: ParticipantInsert): Promise<ParticipantDTO> {
    const { data: participant, error } = await this.supabase
      .from("participants")
      .insert(data)
      .select()
      .single();

    if (error) throw new Error("Failed to create participant");
    return participant;
  }

  async update(id: number, data: ParticipantUpdate): Promise<ParticipantDTO> {
    const { data: participant, error } = await this.supabase
      .from("participants")
      .update(data)
      .eq("id", id)
      .select()
      .single();

    if (error) throw new Error("Failed to update participant");
    return participant;
  }

  async delete(id: number): Promise<void> {
    const { error } = await this.supabase
      .from("participants")
      .delete()
      .eq("id", id);

    if (error) throw new Error("Failed to delete participant");
  }
}

// U≈ºycie w ParticipantService
export class ParticipantService {
  constructor(
    private participantRepo: ParticipantRepository,
    private authService: AuthorizationService
  ) {}

  async addParticipantToGroup(...) {
    // Walidacje...
    const participant = await this.participantRepo.create({
      group_id: groupId,
      user_id: linkedUserId,
      name: command.name,
      email: command.email || null,
      access_token: accessToken,
    });

    return participant;
  }
}
```

**Korzy≈õci:**
- ‚úÖ Separacja data access od business logic
- ‚úÖ ≈Åatwiejsze testowanie (mock repository)
- ‚úÖ Mo≈ºliwo≈õƒá ≈Çatwej zmiany ORM/database w przysz≈Ço≈õci
- ‚úÖ Centralizacja queries (DRY)
- ‚ö†Ô∏è Wymaga du≈ºych zmian w ca≈Çej aplikacji

**Wp≈Çyw:** Poprawa testability, separacja warstw, ale wymaga refaktoringu ca≈Çego projektu

---

### 2Ô∏è‚É£ group.service.ts (651 linii)

**Lokalizacja:** `/home/user/secret-santa/src/lib/services/group.service.ts`

#### üî¥ Zidentyfikowane problemy:

1. **Jedna metoda ma 200+ linii** - `listGroups` (linie 473-649)
   - Skomplikowana logika filtrowania (3 tryby: created, joined, all)
   - Wiele zagnie≈ºd≈ºonych if-√≥w i switch-case
   - Bulk queries (participants count, assignments check)

2. **Duplikacja logiki authorization** - podobna jak w ParticipantService
   - Sprawdzanie creator_id (5 miejsc)
   - Sprawdzanie draw completed (4 miejsca)

3. **Fat method `getGroupById`** - 130 linii (linie 104-229)
   - Fetching z 4 tabel (groups, participants, exclusions, assignments)
   - Obliczanie p√≥l pochodnych (is_drawn, can_edit, drawn_at)
   - Autoryzacja (creator + participant check)

4. **Console.log pollution** - 25+ console.log statements
   - Utrudnia czytanie kodu
   - Powinno byƒá w dedykowanym logger service

#### ‚úÖ Propozycje refaktoryzacji:

##### A) **Wydzielenie GroupListQuery jako osobnej klasy (Query Object Pattern)**

**Priorytet:** üî• WYSOKI (drastyczna redukcja z≈Ço≈ºono≈õci)

```typescript
// services/group/groupListQueryBuilder.ts
export class GroupListQueryBuilder {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Buduje query dla filtra "created"
   */
  private buildCreatedQuery(userId: string) {
    return this.supabase
      .from("groups")
      .select("*")
      .eq("creator_id", userId);
  }

  /**
   * Buduje query dla filtra "joined"
   */
  private async buildJoinedQuery(userId: string, userEmail: string) {
    // Pobierz IDs grup gdzie u≈ºytkownik jest uczestnikiem
    const { data: joinedGroupIds } = await this.supabase
      .from("participants")
      .select("group_id")
      .or(`user_id.eq.${userId},email.eq.${userEmail}`);

    if (!joinedGroupIds || joinedGroupIds.length === 0) {
      return null; // Brak grup
    }

    const groupIds = joinedGroupIds.map((p) => p.group_id);
    return this.supabase
      .from("groups")
      .select("*")
      .in("id", groupIds)
      .neq("creator_id", userId);
  }

  /**
   * Buduje query dla filtra "all"
   */
  private async buildAllQuery(userId: string, userEmail: string) {
    const { data: allParticipations } = await this.supabase
      .from("participants")
      .select("group_id")
      .or(`user_id.eq.${userId},email.eq.${userEmail}`);

    const participantGroupIds = allParticipations?.map((p) => p.group_id) || [];

    if (participantGroupIds.length === 0) {
      return this.supabase
        .from("groups")
        .select("*")
        .eq("creator_id", userId);
    }

    return this.supabase
      .from("groups")
      .select("*")
      .or(`creator_id.eq.${userId},id.in.(${participantGroupIds.join(",")})`);
  }

  /**
   * G≈Ç√≥wna metoda - wykonuje query z paginacjƒÖ
   */
  async execute(
    userId: string,
    userEmail: string,
    filter: "created" | "joined" | "all",
    page: number,
    limit: number
  ): Promise<{ groups: GroupDTO[]; total: number }> {
    let query;
    let countQuery;

    switch (filter) {
      case "created":
        query = this.buildCreatedQuery(userId);
        countQuery = this.buildCreatedQuery(userId);
        break;

      case "joined":
        query = await this.buildJoinedQuery(userId, userEmail);
        countQuery = query;
        if (!query) return { groups: [], total: 0 };
        break;

      case "all":
      default:
        query = await this.buildAllQuery(userId, userEmail);
        countQuery = query;
        break;
    }

    // Execute count
    const { count } = await countQuery.select("id", { count: "exact", head: true });

    // Execute main query with pagination
    const offset = (page - 1) * limit;
    const { data: groups } = await query
      .order("created_at", { ascending: false })
      .range(offset, offset + limit - 1);

    return {
      groups: groups || [],
      total: count || 0,
    };
  }
}

// services/group/groupEnricher.ts
export class GroupEnricher {
  constructor(private supabase: SupabaseClient) {}

  /**
   * Wzbogaca grupy o dodatkowe pola (participants_count, is_drawn)
   */
  async enrich(
    groups: GroupDTO[],
    userId: string
  ): Promise<GroupListItemDTO[]> {
    if (groups.length === 0) return [];

    const groupIds = groups.map((g) => g.id);

    // Bulk query: participants count
    const { data: participantCounts } = await this.supabase
      .from("participants")
      .select("group_id")
      .in("group_id", groupIds);

    const countsByGroup = (participantCounts || []).reduce(
      (acc, p) => {
        acc[p.group_id] = (acc[p.group_id] || 0) + 1;
        return acc;
      },
      {} as Record<number, number>
    );

    // Bulk query: is_drawn
    const { data: drawnGroups } = await this.supabase
      .from("assignments")
      .select("group_id")
      .in("group_id", groupIds);

    const drawnGroupIds = new Set(drawnGroups?.map((a) => a.group_id) || []);

    // Map to GroupListItemDTO
    return groups.map((group) => ({
      ...group,
      is_drawn: drawnGroupIds.has(group.id),
      participants_count: countsByGroup[group.id] || 0,
      is_creator: group.creator_id === userId,
    }));
  }
}

// services/group.service.ts - zredukowane do ~350 linii
export class GroupService {
  private listQueryBuilder: GroupListQueryBuilder;
  private enricher: GroupEnricher;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
    this.listQueryBuilder = new GroupListQueryBuilder(supabase);
    this.enricher = new GroupEnricher(supabase);
  }

  async listGroups(
    userId: UserId,
    userEmail: string,
    query: GroupsListQuery
  ): Promise<PaginatedGroupsDTO> {
    const filter = query.filter || "all";
    const page = query.page || 1;
    const limit = query.limit || 20;

    // Execute query
    const { groups, total } = await this.listQueryBuilder.execute(
      userId,
      userEmail,
      filter,
      page,
      limit
    );

    // Enrich with additional fields
    const enrichedGroups = await this.enricher.enrich(groups, userId);

    // Return paginated response
    return {
      data: enrichedGroups,
      pagination: {
        page,
        limit,
        total,
        total_pages: Math.ceil(total / limit),
      },
    };
  }
}
```

**Korzy≈õci:**
- ‚úÖ Redukcja `listGroups` z 170 linii do ~30 linii
- ‚úÖ Query Object Pattern - ≈Çatwiejsze testowanie queries
- ‚úÖ Separacja logiki budowania query od enrichment
- ‚úÖ Reu≈ºywalno≈õƒá (QueryBuilder mo≈ºna u≈ºyƒá w innych kontekstach)

**Wp≈Çyw:** Redukcja ~140 linii w group.service.ts, dramatyczna poprawa czytelno≈õci

---

##### B) **Logger Service zamiast console.log**

**Priorytet:** üü° ≈öREDNI (poprawa jako≈õci kodu)

```typescript
// lib/logger/loggerService.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

export class LoggerService {
  constructor(
    private serviceName: string,
    private minLevel: LogLevel = LogLevel.INFO
  ) {}

  private log(level: LogLevel, method: string, message: string, data?: any) {
    if (level < this.minLevel) return;

    const timestamp = new Date().toISOString();
    const levelName = LogLevel[level];
    const prefix = `[${timestamp}] [${levelName}] [${this.serviceName}.${method}]`;

    const logData = data ? { ...data } : {};

    switch (level) {
      case LogLevel.ERROR:
        console.error(prefix, message, logData);
        break;
      case LogLevel.WARN:
        console.warn(prefix, message, logData);
        break;
      default:
        console.log(prefix, message, logData);
    }
  }

  debug(method: string, message: string, data?: any) {
    this.log(LogLevel.DEBUG, method, message, data);
  }

  info(method: string, message: string, data?: any) {
    this.log(LogLevel.INFO, method, message, data);
  }

  warn(method: string, message: string, data?: any) {
    this.log(LogLevel.WARN, method, message, data);
  }

  error(method: string, message: string, data?: any) {
    this.log(LogLevel.ERROR, method, message, data);
  }
}

// U≈ºycie w GroupService
export class GroupService {
  private logger: LoggerService;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
    this.logger = new LoggerService("GroupService");
  }

  async getGroupById(...) {
    this.logger.info("getGroupById", "Starting", { groupId, userId });

    // Zamiast console.log
    // console.log("[GroupService.getGroupById] Starting", { groupId, userId });

    // Reszta logiki...

    this.logger.info("getGroupById", "Group found", { groupName: group.name });
    this.logger.error("getGroupById", "Group not found", { groupId, error: groupError?.message });
  }
}
```

**Korzy≈õci:**
- ‚úÖ Centralne zarzƒÖdzanie logami
- ‚úÖ Mo≈ºliwo≈õƒá wy≈ÇƒÖczenia log√≥w na produkcji (minLevel)
- ‚úÖ Sp√≥jny format log√≥w
- ‚úÖ ≈Åatwiejsza integracja z zewnƒôtrznymi systemami (Sentry, LogRocket)
- ‚úÖ Type-safe logging

**Wp≈Çyw:** Lepsza jako≈õƒá kodu, profesjonalny logging

---

### 3Ô∏è‚É£ results.service.ts (504 linie)

**Lokalizacja:** `/home/user/secret-santa/src/lib/services/results.service.ts`

#### üî¥ Zidentyfikowane problemy:

1. **Duplikacja logiki w 2 metodach g≈Ç√≥wnych** (linie 58-123 vs 133-196)
   - `getAuthenticatedUserResult` (65 linii)
   - `getTokenBasedResult` (63 linie)
   - 90% logiki jest identyczna, r√≥≈ºni siƒô tylko walidacja dostƒôpu

2. **Prywatna metoda z 10 parametrami** - `validateDrawCompletedAndGetParticipant`
   - Linie 202-292 (90 linii)
   - Zbyt wiele opcjonalnych parametr√≥w
   - Switch logic na `accessType`

3. **Formatting helpers jako metody** - formatGroupInfo, formatParticipantInfo, etc.
   - Powinny byƒá pure functions w utils
   - Nie potrzebujƒÖ dostƒôpu do `this`

4. **Powtarzana logika date validation**
   - Linii 89-106 vs 162-179
   - Identyczna logika `isExpired` w dw√≥ch miejscach

#### ‚úÖ Propozycje refaktoryzacji:

##### A) **Strategy Pattern dla access methods**

**Priorytet:** üî• WYSOKI (eliminuje 90% duplikacji)

```typescript
// services/results/accessStrategy.ts
export interface ResultAccessStrategy {
  validate(
    groupId: number | undefined,
    identifier: string | undefined
  ): Promise<{ participant: ParticipantData; group: GroupInfo }>;
}

// services/results/authenticatedAccessStrategy.ts
export class AuthenticatedAccessStrategy implements ResultAccessStrategy {
  constructor(private supabase: SupabaseClient) {}

  async validate(groupId: number | undefined, userId: string | undefined) {
    if (!groupId || !userId) {
      throw new Error("INVALID_PARAMS");
    }

    // Check draw completed
    const { data: assignments } = await this.supabase
      .from("assignments")
      .select("id")
      .eq("group_id", groupId)
      .limit(1);

    if (!assignments || assignments.length === 0) {
      throw new Error("DRAW_NOT_COMPLETED");
    }

    // Get group
    const { data: group } = await this.supabase
      .from("groups")
      .select("id, name, budget, end_date")
      .eq("id", groupId)
      .single();

    if (!group) {
      throw new Error("GROUP_NOT_FOUND");
    }

    // Get participant
    const { data: participant } = await this.supabase
      .from("participants")
      .select("id, group_id, user_id, name, email, result_viewed_at")
      .eq("group_id", groupId)
      .eq("user_id", userId)
      .single();

    if (!participant) {
      throw new Error("FORBIDDEN");
    }

    return { participant, group };
  }
}

// services/results/tokenAccessStrategy.ts
export class TokenAccessStrategy implements ResultAccessStrategy {
  constructor(private supabase: SupabaseClient) {}

  async validate(groupId: number | undefined, token: string | undefined) {
    if (!token) {
      throw new Error("INVALID_PARAMS");
    }

    // Get participant by token
    const { data: participant } = await this.supabase
      .from("participants")
      .select("id, group_id, user_id, name, email, result_viewed_at")
      .eq("access_token", token)
      .single();

    if (!participant) {
      throw new Error("INVALID_TOKEN");
    }

    // Check draw completed
    const { data: assignments } = await this.supabase
      .from("assignments")
      .select("id")
      .eq("group_id", participant.group_id)
      .limit(1);

    if (!assignments || assignments.length === 0) {
      throw new Error("DRAW_NOT_COMPLETED");
    }

    // Get group
    const { data: group } = await this.supabase
      .from("groups")
      .select("id, name, budget, end_date")
      .eq("id", participant.group_id)
      .single();

    if (!group) {
      throw new Error("GROUP_NOT_FOUND");
    }

    return { participant, group };
  }
}

// services/results.service.ts - zredukowane do ~250 linii
export class ResultsService {
  private authenticatedAccess: AuthenticatedAccessStrategy;
  private tokenAccess: TokenAccessStrategy;

  constructor(supabase: SupabaseClient) {
    this.supabase = supabase;
    this.authenticatedAccess = new AuthenticatedAccessStrategy(supabase);
    this.tokenAccess = new TokenAccessStrategy(supabase);
  }

  /**
   * Uniwersalna metoda dla obu typ√≥w dostƒôpu
   */
  async getDrawResult(
    accessType: "authenticated" | "token",
    identifier: { groupId?: number; userId?: string; token?: string }
  ): Promise<DrawResultResponseDTO> {
    // Wybierz strategiƒô
    const strategy = accessType === "authenticated"
      ? this.authenticatedAccess
      : this.tokenAccess;

    // Walidacja i pobranie danych
    const { participant, group } = await strategy.validate(
      identifier.groupId,
      accessType === "authenticated" ? identifier.userId : identifier.token
    );

    // Wsp√≥lna logika dla obu przypadk√≥w
    const { assignedParticipant, assignedWishlist } = await this.getAssignedParticipantData(
      participant.group_id,
      participant.id
    );

    const myWishlist = await this.getParticipantWishlist(participant.id);
    const wishlistStats = await this.getWishlistStats(participant.group_id);

    // Date validation (wsp√≥lna)
    const canEdit = this.canEditWishlist(group.end_date);

    // Format response
    return {
      group: this.formatGroupInfo(group),
      participant: this.formatParticipantInfo(participant),
      assigned_to: this.formatAssignedParticipant(assignedParticipant, assignedWishlist),
      my_wishlist: this.formatMyWishlist(myWishlist, canEdit),
      wishlist_stats: wishlistStats,
    };
  }

  // Public API - wrapper methods
  async getAuthenticatedUserResult(groupId: number, userId: string) {
    return this.getDrawResult("authenticated", { groupId, userId });
  }

  async getTokenBasedResult(token: string) {
    return this.getDrawResult("token", { token });
  }

  /**
   * Wsp√≥lna logika date validation
   */
  private canEditWishlist(groupEndDate: string): boolean {
    const now = new Date();
    const endDate = new Date(groupEndDate);
    const nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

    return nowDate <= endDateOnly;
  }
}
```

**Korzy≈õci:**
- ‚úÖ Eliminacja 90% duplikacji miƒôdzy dwiema metodami
- ‚úÖ Strategy Pattern - ≈Çatwe dodanie nowych typ√≥w dostƒôpu
- ‚úÖ Ka≈ºda strategia testowalna osobno
- ‚úÖ Redukcja z 504 do ~250 linii

**Wp≈Çyw:** Redukcja ~250 linii, dramatyczna poprawa DRY

---

##### B) **Wydzielenie formatters do utils**

**Priorytet:** üü° ≈öREDNI

```typescript
// lib/utils/resultFormatters.ts
export const resultFormatters = {
  formatGroupInfo(group: { id: number; name: string; budget: number; end_date: string }): ResultGroupInfo {
    return {
      id: group.id,
      name: group.name,
      budget: group.budget,
      end_date: group.end_date,
    };
  },

  formatParticipantInfo(participant: { id: number; name: string; result_viewed_at: string | null }): ResultParticipantInfo {
    return {
      id: participant.id,
      name: participant.name,
      result_viewed_at: participant.result_viewed_at || undefined,
    };
  },

  formatAssignedParticipant(
    assignedParticipant: { id: number; name: string },
    wishlist: string | null
  ): ResultAssignedParticipant {
    return {
      id: assignedParticipant.id,
      name: assignedParticipant.name,
      wishlist: wishlist || undefined,
    };
  },

  formatMyWishlist(wishlist: string | null, canEdit: boolean): ResultMyWishlist {
    return {
      content: wishlist || undefined,
      can_edit: canEdit,
    };
  },
};

// services/results.service.ts
import { resultFormatters } from "@/lib/utils/resultFormatters";

export class ResultsService {
  async getDrawResult(...) {
    return {
      group: resultFormatters.formatGroupInfo(group),
      participant: resultFormatters.formatParticipantInfo(participant),
      // ...
    };
  }
}
```

**Korzy≈õci:**
- ‚úÖ Pure functions - ≈Çatwiejsze testowanie
- ‚úÖ Reu≈ºywalno≈õƒá w innych miejscach
- ‚úÖ Separacja formatowania od logiki biznesowej

**Wp≈Çyw:** Redukcja ~50 linii, lepsza organizacja

---

### 4Ô∏è‚É£ wishlist.service.ts (484 linie)

**Lokalizacja:** `/home/user/secret-santa/src/lib/services/wishlist.service.ts`

#### üî¥ Zidentyfikowane problemy:

1. **Duplikacja walidacji dostƒôpu** - 3 metody z identycznƒÖ logikƒÖ
   - `createOrUpdateWishlist` (linie 42-123)
   - `getWishlist` (linie 264-335)
   - `deleteWishlist` (linie 357-435)
   - Wszystkie wywo≈ÇujƒÖ `validateWishlistAccess`

2. **Duplikacja date validation** - 2 miejsca z identycznƒÖ logikƒÖ
   - Linie 73-88 (createOrUpdate)
   - Linie 386-401 (delete)
   - Identyczna logika por√≥wnywania dat

3. **Metoda `validateWishlistAccess` z 4 parametrami** (144-189)
   - Skomplikowana logika Case 1 / Case 2 / Case 3
   - Mo≈ºna upro≈õciƒá u≈ºywajƒÖc Early Return Pattern

4. **Prywatny helper `renderWishlistHtml`** (449-466)
   - Powinien byƒá w osobnym utils (reu≈ºywalno≈õƒá)
   - Security concern - manual HTML escaping

#### ‚úÖ Propozycje refaktoryzacji:

##### A) **Template Method Pattern dla CRUD operations**

**Priorytet:** üî• WYSOKI (eliminuje duplikacjƒô)

```typescript
// services/wishlist/wishlistBaseOperation.ts
export abstract class WishlistBaseOperation<T> {
  constructor(protected supabase: SupabaseClient) {}

  /**
   * Template Method - definiuje szkielet algorytmu
   */
  async execute(
    participantId: number,
    authUserId: UserId | null,
    participantToken: string | null,
    additionalData?: any
  ): Promise<T> {
    // Step 1: Validate participant exists
    const participantWithGroup = await this.getParticipantWithGroupInfo(participantId);
    if (!participantWithGroup) {
      throw new Error("PARTICIPANT_NOT_FOUND");
    }

    // Step 2: Validate access
    await this.validateWishlistAccess(
      participantId,
      authUserId,
      participantToken,
      participantWithGroup
    );

    // Step 3: Check end date (je≈õli wymagane)
    if (this.requiresEndDateCheck()) {
      this.validateEndDate(participantWithGroup.group.end_date);
    }

    // Step 4: Execute specific operation (hook method)
    return await this.performOperation(participantId, participantWithGroup, additionalData);
  }

  /**
   * Hook method - implementowany przez podklasy
   */
  protected abstract performOperation(
    participantId: number,
    participantWithGroup: ParticipantWithGroupDTO,
    additionalData?: any
  ): Promise<T>;

  /**
   * Hook method - okre≈õla czy sprawdzaƒá datƒô
   */
  protected requiresEndDateCheck(): boolean {
    return true; // Domy≈õlnie tak
  }

  // Wsp√≥lne metody pomocnicze
  private async getParticipantWithGroupInfo(...) { /* ... */ }
  private async validateWishlistAccess(...) { /* ... */ }
  private validateEndDate(groupEndDate: string): void {
    const now = new Date();
    const endDate = new Date(groupEndDate);
    const nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());

    if (nowDate > endDateOnly) {
      throw new Error("END_DATE_PASSED");
    }
  }
}

// services/wishlist/createOrUpdateWishlistOperation.ts
export class CreateOrUpdateWishlistOperation extends WishlistBaseOperation<WishlistDTO> {
  protected async performOperation(
    participantId: number,
    participantWithGroup: ParticipantWithGroupDTO,
    command: CreateOrUpdateWishlistCommand
  ): Promise<WishlistDTO> {
    const { data: wishlist, error } = await this.supabase
      .from("wishes")
      .upsert(
        {
          participant_id: participantId,
          wishlist: command.wishlist,
          updated_at: new Date().toISOString(),
        },
        { onConflict: "participant_id", ignoreDuplicates: false }
      )
      .select()
      .single();

    if (error || !wishlist) {
      throw new Error("Failed to create/update wishlist");
    }

    return wishlist;
  }
}

// services/wishlist/getWishlistOperation.ts
export class GetWishlistOperation extends WishlistBaseOperation<WishlistWithHtmlDTO> {
  // Dla GET nie sprawdzamy end date
  protected requiresEndDateCheck(): boolean {
    return false;
  }

  protected async performOperation(
    participantId: number,
    participantWithGroup: ParticipantWithGroupDTO
  ): Promise<WishlistWithHtmlDTO> {
    const { data: wishlist, error } = await this.supabase
      .from("wishes")
      .select("*")
      .eq("participant_id", participantId)
      .single();

    if (error || !wishlist) {
      throw new Error("WISHLIST_NOT_FOUND");
    }

    const wishlistHtml = renderWishlistHtml(wishlist.wishlist); // Pure function z utils
    const canEdit = !isDateExpired(participantWithGroup.group.end_date); // Pure function z utils

    return {
      ...wishlist,
      wishlist_html: wishlistHtml,
      can_edit: canEdit,
    };
  }
}

// services/wishlist/deleteWishlistOperation.ts
export class DeleteWishlistOperation extends WishlistBaseOperation<void> {
  protected async performOperation(participantId: number): Promise<void> {
    // Check if exists
    const { data: existing } = await this.supabase
      .from("wishes")
      .select("id")
      .eq("participant_id", participantId)
      .single();

    if (!existing) {
      throw new Error("WISHLIST_NOT_FOUND");
    }

    // Delete
    const { error } = await this.supabase
      .from("wishes")
      .delete()
      .eq("participant_id", participantId);

    if (error) {
      throw new Error("Failed to delete wishlist");
    }
  }
}

// services/wishlist.service.ts - zredukowane do ~150 linii
export class WishlistService {
  private createOrUpdateOp: CreateOrUpdateWishlistOperation;
  private getOp: GetWishlistOperation;
  private deleteOp: DeleteWishlistOperation;

  constructor(supabase: SupabaseClient) {
    this.createOrUpdateOp = new CreateOrUpdateWishlistOperation(supabase);
    this.getOp = new GetWishlistOperation(supabase);
    this.deleteOp = new DeleteWishlistOperation(supabase);
  }

  async createOrUpdateWishlist(
    participantId: number,
    command: CreateOrUpdateWishlistCommand,
    authUserId: UserId | null,
    participantToken: string | null
  ): Promise<WishlistDTO> {
    return this.createOrUpdateOp.execute(participantId, authUserId, participantToken, command);
  }

  async getWishlist(
    participantId: number,
    authUserId: UserId | null,
    participantToken: string | null
  ): Promise<WishlistWithHtmlDTO> {
    return this.getOp.execute(participantId, authUserId, participantToken);
  }

  async deleteWishlist(
    participantId: number,
    authUserId: UserId | null,
    participantToken: string | null
  ): Promise<void> {
    return this.deleteOp.execute(participantId, authUserId, participantToken);
  }
}
```

**Korzy≈õci:**
- ‚úÖ Eliminacja duplikacji walidacji i date check
- ‚úÖ Template Method - wsp√≥lny szkielet algorytmu
- ‚úÖ Ka≈ºda operacja testowalna osobno
- ‚úÖ Redukcja z 484 do ~150 linii w g≈Ç√≥wnym serwisie

**Wp≈Çyw:** Redukcja ~330 linii duplikacji, lepszy OOP design

---

##### B) **Security-focused HTML Sanitizer**

**Priorytet:** üü° ≈öREDNI (security improvement)

```typescript
// lib/utils/htmlSanitizer.ts
import DOMPurify from "dompurify";

/**
 * Bezpieczne renderowanie wishlist z auto-linkingiem
 * U≈ºywa DOMPurify dla ochrony przed XSS
 */
export function renderWishlistHtml(text: string): string {
  if (!text) return "";

  // Auto-link URLs
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  const linked = text.replace(urlRegex, (url) => {
    return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${url}</a>`;
  });

  // Convert line breaks
  const withBreaks = linked.replace(/\n/g, "<br>");

  // Sanitize with DOMPurify (removes malicious code)
  return DOMPurify.sanitize(withBreaks, {
    ALLOWED_TAGS: ["a", "br"],
    ALLOWED_ATTR: ["href", "target", "rel", "class"],
  });
}
```

**Korzy≈õci:**
- ‚úÖ Protection against XSS attacks
- ‚úÖ Industry-standard library (DOMPurify)
- ‚úÖ Whitelist approach (bezpieczniejsze)
- ‚ö†Ô∏è Wymaga dodania dependencji `dompurify`

**Wp≈Çyw:** Poprawa security, profesjonalna sanityzacja HTML

---

### 5Ô∏è‚É£ exclusion-rule.service.ts (420 linii)

**Lokalizacja:** `/home/user/secret-santa/src/lib/services/exclusion-rule.service.ts`

#### üî¥ Zidentyfikowane problemy:

1. **Powtarzana logika autoryzacji** - identyczna jak w innych serwisach
   - `createExclusionRule` - 60 linii walidacji (linie 45-163)
   - `deleteExclusionRule` - 40 linii walidacji (linie 330-418)

2. **Metoda z 7 walidacjami** - `createExclusionRule`
   - Guard 1: groupId/userId exists
   - Guard 2: group exists
   - Guard 3: user is creator
   - Guard 4: draw not completed
   - Guard 5: participants are different
   - Guard 6: participants exist in group
   - Guard 7: no duplicate rule

3. **JOIN query z aliasami** - `getExclusionRulesForGroup` (linie 215-310)
   - Skomplikowane aliasy dla foreign keys
   - Transformacja danych na ko≈Ñcu (lines 290-298)

#### ‚úÖ Propozycje refaktoryzacji:

##### A) **Validation Chain Pattern**

**Priorytet:** üü° ≈öREDNI

```typescript
// services/validation/validationChain.ts
export class ValidationChain {
  private validators: Array<() => Promise<void>> = [];

  add(validator: () => Promise<void>): this {
    this.validators.push(validator);
    return this;
  }

  async execute(): Promise<void> {
    for (const validator of this.validators) {
      await validator();
    }
  }
}

// services/exclusionRule.service.ts
export class ExclusionRuleService {
  async createExclusionRule(
    groupId: number,
    userId: UserId,
    command: CreateExclusionRuleCommand
  ): Promise<ExclusionRuleDTO> {
    // Zamiast 7 osobnych blok√≥w try-catch i if-√≥w:
    const validation = new ValidationChain()
      .add(async () => {
        const { canModify, reason } = await this.authService.canModifyGroup(userId, groupId);
        if (!canModify) throw new Error(reason);
      })
      .add(async () => {
        if (command.blocker_participant_id === command.blocked_participant_id) {
          throw new Error("SAME_PARTICIPANT");
        }
      })
      .add(async () => {
        const bothExist = await this.validateParticipantsExist(
          groupId,
          [command.blocker_participant_id, command.blocked_participant_id]
        );
        if (!bothExist) throw new Error("INVALID_PARTICIPANTS");
      })
      .add(async () => {
        const duplicate = await this.checkDuplicateRule(groupId, command);
        if (duplicate) throw new Error("DUPLICATE_RULE");
      });

    await validation.execute();

    // Insert rule
    const exclusionRule = await this.exclusionRepo.create({
      group_id: groupId,
      blocker_participant_id: command.blocker_participant_id,
      blocked_participant_id: command.blocked_participant_id,
    });

    return exclusionRule;
  }
}
```

**Korzy≈õci:**
- ‚úÖ Czytelny flow walidacji
- ‚úÖ ≈Åatwe dodawanie/usuwanie walidacji
- ‚úÖ Testowalne osobno
- ‚úÖ Redukcja zagnie≈ºd≈ºenia

**Wp≈Çyw:** Redukcja ~30 linii, lepsza czytelno≈õƒá

---

## 3. Plan implementacji (prioritization)

### üî• Faza 1: Quick Wins (Wysokie Priority - 2-3 dni)

#### 1.1 AuthorizationService (6-8h)

**Cel:** Eliminacja duplikacji autoryzacji w 5 serwisach

**Zadania:**
- [ ] Utworzyƒá `services/authorizationService.ts`
- [ ] Implementowaƒá metody: `isGroupCreator`, `isDrawCompleted`, `canModifyGroup`
- [ ] Zaktualizowaƒá ParticipantService do u≈ºywania AuthorizationService
- [ ] Zaktualizowaƒá GroupService do u≈ºywania AuthorizationService
- [ ] Zaktualizowaƒá ExclusionRuleService do u≈ºywania AuthorizationService
- [ ] Dodaƒá testy dla AuthorizationService
- [ ] Commit: `refactor(services): extract AuthorizationService to eliminate duplication`

**Impact:** ~200 linii mniej w sumie, DRY

#### 1.2 GroupListQueryBuilder (4-6h)

**Cel:** Redukcja complexity `listGroups` z 170 do 30 linii

**Zadania:**
- [ ] Utworzyƒá `services/group/groupListQueryBuilder.ts`
- [ ] Utworzyƒá `services/group/groupEnricher.ts`
- [ ] Refaktorowaƒá `group.service.ts#listGroups`
- [ ] Dodaƒá testy dla QueryBuilder i Enricher
- [ ] Commit: `refactor(group): extract list query logic to Query Builder pattern`

**Impact:** ~140 linii mniej, dramatyczna poprawa czytelno≈õci

#### 1.3 ResultsService Strategy Pattern (5-7h)

**Cel:** Eliminacja 90% duplikacji miƒôdzy authenticated i token access

**Zadania:**
- [ ] Utworzyƒá folder `services/results/`
- [ ] Implementowaƒá `AuthenticatedAccessStrategy`
- [ ] Implementowaƒá `TokenAccessStrategy`
- [ ] Refaktorowaƒá `results.service.ts`
- [ ] Dodaƒá testy dla strategii
- [ ] Commit: `refactor(results): implement Strategy Pattern for access methods`

**Impact:** Redukcja ~250 linii, DRY

---

### üü° Faza 2: Architecture Improvements (≈örednie Priority - 4-6 dni)

#### 2.1 LoggerService (3-4h)

**Zadania:**
- [ ] Utworzyƒá `lib/logger/loggerService.ts`
- [ ] ZastƒÖpiƒá console.log w GroupService
- [ ] ZastƒÖpiƒá console.log w ParticipantService
- [ ] ZastƒÖpiƒá console.log w ResultsService
- [ ] Commit: `feat(logger): add centralized logger service`

**Impact:** Profesjonalny logging, lepsza jako≈õƒá kodu

#### 2.2 Wishlist Template Method Pattern (5-7h)

**Zadania:**
- [ ] Utworzyƒá folder `services/wishlist/`
- [ ] Implementowaƒá `WishlistBaseOperation` (abstract)
- [ ] Implementowaƒá konkretne operacje (Create, Get, Delete)
- [ ] Refaktorowaƒá `wishlist.service.ts`
- [ ] Dodaƒá testy
- [ ] Commit: `refactor(wishlist): implement Template Method pattern`

**Impact:** Redukcja ~330 linii, lepszy OOP

#### 2.3 Formatters do utils (2-3h)

**Zadania:**
- [ ] Utworzyƒá `lib/utils/resultFormatters.ts`
- [ ] Przenie≈õƒá formattery z ResultsService
- [ ] Zaktualizowaƒá ResultsService
- [ ] Dodaƒá testy dla pure functions
- [ ] Commit: `refactor: move result formatters to utils`

**Impact:** ~50 linii mniej, reu≈ºywalno≈õƒá

#### 2.4 HTML Sanitizer (2-3h)

**Zadania:**
- [ ] Zainstalowaƒá `dompurify` + `@types/dompurify`
- [ ] Utworzyƒá `lib/utils/htmlSanitizer.ts`
- [ ] ZastƒÖpiƒá manual escaping w WishlistService
- [ ] Dodaƒá testy security
- [ ] Commit: `feat(security): add DOMPurify for HTML sanitization`

**Impact:** Poprawa security, XSS protection

---

### üîµ Faza 3: Advanced (Niskie Priority - opcjonalnie)

#### 3.1 Service Composition - podzia≈Ç na mniejsze serwisy (10-15h)

**Zadania:**
- [ ] Podzieliƒá ParticipantService na: CRUD, Query, Validation, Tracking
- [ ] Podzieliƒá GroupService na: CRUD, Query
- [ ] Implementowaƒá Facade Pattern
- [ ] Zaktualizowaƒá wszystkie importy
- [ ] Commit: `refactor: implement Service Composition pattern`

**Impact:** Lepszy SRP, ale wymaga du≈ºego refaktoringu

#### 3.2 Repository Pattern (15-20h)

**Zadania:**
- [ ] Utworzyƒá repositories dla ka≈ºdej tabeli
- [ ] Wydzieliƒá data access od business logic
- [ ] Zaktualizowaƒá wszystkie serwisy
- [ ] Commit: `refactor: implement Repository pattern for data access`

**Impact:** Separacja warstw, ale wymaga refaktoringu ca≈Çej aplikacji

---

## 4. Podsumowanie metryk

### Przed refaktoryzacjƒÖ:

| Metryka                | Warto≈õƒá |
|------------------------|---------|
| **Ca≈Çkowite LOC (TOP 5)** | **2829** |
| ≈örednia LOC/service    | 566     |
| Duplikacja kodu        | ~20%    |
| God Services           | 2 (ParticipantService, GroupService) |
| Console.log statements | 60+     |

### Po refaktoryzacji (Faza 1 + 2):

| Metryka                | Warto≈õƒá | Zmiana |
|------------------------|---------|--------|
| **Ca≈Çkowite LOC (TOP 5)** | **~1500** | **-47%** ‚úÖ |
| ≈örednia LOC/service    | ~300    | -47% ‚úÖ |
| Duplikacja kodu        | ~5%     | -75% ‚úÖ |
| God Services           | 0       | -100% ‚úÖ |
| Console.log statements | 0       | -100% ‚úÖ |

### Kluczowe korzy≈õci:

‚úÖ **Maintainability:** 47% redukcja LOC = ≈Çatwiejsze zrozumienie
‚úÖ **DRY:** 75% redukcja duplikacji (AuthorizationService, Strategy Pattern)
‚úÖ **Security:** XSS protection z DOMPurify
‚úÖ **Testability:** Mniejsze, focused serwisy/strategiek≈Çy
‚úÖ **Professional:** Centralized logger zamiast console.log
‚úÖ **Architecture:** Service Layer properly implemented

---

## 5. Kluczowe wzorce i techniki

### Rekomendowane dla Service Layer:

1. **AuthorizationService** - centralizacja logiki autoryzacji
2. **Strategy Pattern** - dla r√≥≈ºnych typ√≥w dostƒôpu (authenticated vs token)
3. **Template Method Pattern** - dla operacji CRUD z wsp√≥lnym szkieletem
4. **Query Object Pattern** - dla skomplikowanych queries
5. **Validation Chain** - dla sekwencyjnych walidacji
6. **Logger Service** - centralized, structured logging
7. **Repository Pattern** (optional) - separacja data access
8. **Service Composition** (optional) - podzia≈Ç God Services

### Zgodne z:

- ‚úÖ SOLID principles (szczeg√≥lnie SRP i DIP)
- ‚úÖ DRY (Don't Repeat Yourself)
- ‚úÖ TypeScript strict mode
- ‚úÖ Node.js + Supabase best practices
- ‚úÖ Security best practices (XSS protection)
- ‚úÖ Testability (Vitest-friendly)

---

## 6. Nastƒôpne kroki

### Natychmiast:

1. ‚úÖ PrzeglƒÖd dokumentu przez zesp√≥≈Ç
2. ‚è≥ Decyzja o priorytetach (Faza 1 obowiƒÖzkowa?)
3. ‚è≥ Decyzja o Fazie 3 (Repository Pattern - tak/nie?)
4. ‚è≥ Utworzenie task√≥w w GitHub Issues
5. ‚è≥ Przypisanie do sprintu

### Podczas implementacji:

- Tworzyƒá ma≈Çe, atomiczne commity
- Uruchamiaƒá testy po ka≈ºdej zmianie
- Code review przed merge
- Aktualizowaƒá dokumentacjƒô

### Po zako≈Ñczeniu:

- Zmierzyƒá metryki
- Por√≥wnaƒá z baseline
- Retrospekcja

---

## 7. Ryzyka i mitygacja

| Ryzyko | Prawdopodobie≈Ñstwo | Wp≈Çyw | Mitygacja |
|--------|-------------------|-------|-----------|
| Breaking changes w API endpoints | ≈örednie | Wysoki | Pe≈Çne testy E2E przed merge |
| Regresje w logice autoryzacji | Niskie | Krytyczny | Szczeg√≥≈Çowe testy AuthorizationService |
| Performance degradation | Niskie | ≈öredni | Benchmarki przed/po (szczeg√≥lnie GroupListQuery) |
| Zwiƒôkszenie complexity | Niskie | ≈öredni | Code review, pair programming |

---

**Dokument utworzony:** 05.11.2025
**Autor:** Claude Code Agent
**Status:** ‚úÖ Ready for Review
**Nastƒôpna aktualizacja:** Po code review zespo≈Çu
